<?xml version="1.0" encoding="utf-8"?>
<schema packageName="truss.compiler.syntax">
    <class name="SyntaxNode" abstract="true" ignore="true">
        <property name="Span" type="Span" last="true"/>
    </class>
    <class name="AccessorDeclarationSyntax" base="SyntaxNode">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Modifiers" type="Modifier" list="true"/>
        <property name="Type" type="AccessorDeclarationType"/>
        <property name="Body" type="BlockSyntax"/>
    </class>
    <class name="ArgumentSyntax" base="SyntaxNode">
        <property name="Modifier" type="ParameterModifier" list="true"/>
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="AttributeListSyntax" base="SyntaxNode">
        <property name="Target" type="AttributeTarget"/>
        <property name="Attributes" type="AttributeSyntax" list="true"/>
    </class>
    <class name="AttributeSyntax" base="SyntaxNode">
        <property name="Name" type="NameSyntax"/>
        <property name="Arguments" type="AttributeArgumentSyntax" list="true"/>
    </class>
    <class name="AttributeArgumentSyntax" base="SyntaxNode">
        <property name="Name" type="IdentifierNameSyntax" nullable="true"/>
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="CatchClauseSyntax" base="SyntaxNode">
        <property name="ExceptionType" type="TypeSyntax" nullable="true"/>
        <property name="Identifier" type="IdentifierNameSyntax" nullable="true"/>
        <property name="Block" type="BlockSyntax"/>
    </class>
    <class name="CompilationUnitSyntax" base="SyntaxNode">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Imports" type="ImportDirectiveSyntax" list="true"/>
        <property name="Members" type="MemberDeclarationSyntax" list="true"/>
    </class>
    <class name="ExpressionSyntax" abstract="true" base="SyntaxNode"/>
    <class name="AnonymousObjectCreationExpressionSyntax" base="ExpressionSyntax">
        <property name="Initializers" type="AnonymousObjectMemberDeclaratorSyntax" list="true"/>
    </class>
    <class name="AnonymousObjectMemberDeclaratorSyntax" base="SyntaxNode">
        <property name="Name" type="IdentifierNameSyntax"/>
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="ArrayCreationExpressionSyntax" base="ExpressionSyntax">
        <property name="Type" type="ArrayTypeSyntax"/>
        <property name="Initializer" type="ExpressionSyntax"/>
    </class>
    <class name="AwaitExpressionSyntax" base="ExpressionSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="BinaryExpressionSyntax" base="ExpressionSyntax">
        <property name="Operator" type="BinaryOperator"/>
        <property name="Left" type="ExpressionSyntax"/>
        <property name="Right" type="ExpressionSyntax"/>
    </class>
    <class name="CastExpressionSyntax" base="ExpressionSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="TargetType" type="TypeSyntax"/>
    </class>
    <class name="ConditionalExpressionSyntax" base="ExpressionSyntax">
        <property name="Condition" type="ExpressionSyntax"/>
        <property name="WhenFalse" type="ExpressionSyntax"/>
        <property name="WhenTrue" type="ExpressionSyntax"/>
    </class>
    <class name="DefaultExpressionSyntax" base="ExpressionSyntax">
        <property name="TargetType" type="TypeSyntax"/>
    </class>
    <!-- Array index: e[10] -->
    <class name="ElementAccessExpressionSyntax" base="ExpressionSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="IndexExpression" type="ExpressionSyntax"/>
    </class>
    <class name="ImplicitArrayCreationExpressionSyntax" base="ExpressionSyntax">
        <property name="Initializer" type="ExpressionSyntax" list="true"/>
    </class>
    <class name="InstanceExpressionSyntax" base="ExpressionSyntax">
        <property name="Type" type="ThisOrBase"/>
    </class>
    <class name="InvocationExpressionSyntax" base="ExpressionSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Arguments" type="ArgumentSyntax" list="true"/>
    </class>
    <class name="LiteralExpressionSyntax" base="ExpressionSyntax">
        <property name="LiteralType" type="LiteralType"/>
        <property name="Value" type="String" nullable="true"/>
    </class>
    <class name="MemberAccessExpressionSyntax" base="ExpressionSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Name" type="SimpleNameSyntax"/>
    </class>
    <class name="ObjectCreationExpressionSyntax" base="ExpressionSyntax">
        <property name="TargetType" type="TypeSyntax"/>
        <property name="Arguments" type="ArgumentSyntax" list="true"/>
        <!-- Represents { a = 7, b = 3 } -->
        <property name="Initializers" type="ExpressionSyntax" list="true"/>
    </class>
    <class name="OmittedArraySizeExpressionSyntax" base="ExpressionSyntax"/>
    <class name="ParenthesizedExpressionSyntax" base="ExpressionSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="LambdaExpressionSyntax" base="ExpressionSyntax">
        <property name="Modifiers" type="Modifier" list="true"/>
        <property name="Parameters" type="ParameterSyntax" list="true"/>
        <property name="Body" type="SyntaxNode"/>
    </class>
    <class name="PostfixUnaryExpressionSyntax" base="ExpressionSyntax">
        <property name="Operator" type="PostfixUnaryOperator"/>
        <property name="Operand" type="ExpressionSyntax"/>
    </class>
    <class name="PrefixUnaryExpressionSyntax" base="ExpressionSyntax">
        <property name="Operator" type="PrefixUnaryOperator"/>
        <property name="Operand" type="ExpressionSyntax"/>
    </class>
    <class name="SizeOfExpressionSyntax" base="ExpressionSyntax">
        <property name="TargetType" type="TypeSyntax"/>
    </class>
    <class name="TypeOfExpressionSyntax" base="ExpressionSyntax">
        <property name="TargetType" type="TypeSyntax"/>
    </class>
    <class name="TypeSyntax" abstract="true" base="ExpressionSyntax">
        <members><![CDATA[
            public boolean isVar() {
                if (this instanceof IdentifierNameSyntax) {
                    return "var".equals(((IdentifierNameSyntax)this).getIdentifier());
                }
                return false;
            }
        ]]>
        </members>
    </class>
    <class name="VariableDeclarationExpressionSyntax" base="ExpressionSyntax">
        <property name="VariableType" type="TypeSyntax"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
    </class>
    <class name="ArrayTypeSyntax" base="TypeSyntax">
        <property name="ElementType" type="TypeSyntax"/>
    </class>
    <class name="NameSyntax" abstract="true" base="TypeSyntax"/>
    <class name="AliasQualifiedNameSyntax" base="NameSyntax">
        <property name="Alias" type="IdentifierNameSyntax"/>
        <property name="Name" type="SimpleNameSyntax"/>
    </class>
    <class name="QualifiedNameSyntax" base="NameSyntax">
        <property name="Left" type="NameSyntax"/>
        <property name="Right" type="SimpleNameSyntax"/>
    </class>
    <class name="SimpleNameSyntax" abstract="true" base="NameSyntax">
        <property name="Identifier" type="String"/>
    </class>
    <class name="GenericNameSyntax" base="SimpleNameSyntax">
        <property name="TypeArguments" type="TypeSyntax" list="true"/>
        <members><![CDATA[
            public boolean isUnboundGenericName() {
                for (TypeSyntax argument : getTypeArguments()) {
                    if (argument instanceof OmittedTypeArgumentSyntax) {
                        return true;
                    }
                }

                return false;
            }
        ]]>
        </members>
    </class>
    <!--
    "var" does not have a construct so as to not have to make it a keyword. Instead, an IdentifierNameSyntax
    with the name "var" is a var type.
    -->
    <class name="IdentifierNameSyntax" base="SimpleNameSyntax"/>
    <class name="NakedNullableTypeSyntax" base="TypeSyntax">
        <property name="Type" type="NakedNullableType"/>
    </class>
    <class name="NullableTypeSyntax" base="TypeSyntax">
        <property name="ElementType" type="TypeSyntax"/>
    </class>
    <class name="OmittedTypeArgumentSyntax" base="TypeSyntax"/>
    <class name="PredefinedTypeSyntax" base="TypeSyntax">
        <property name="PredefinedType" type="PredefinedType"/>
    </class>
    <class name="MemberDeclarationSyntax" abstract="true" base="SyntaxNode"/>
    <class name="BaseFieldDeclarationSyntax" base="MemberDeclarationSyntax" abstract="true">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Modifiers" type="Modifier" list="true"/>
        <property name="Declaration" type="VariableDeclarationSyntax"/>
    </class>
    <class name="FieldDeclarationSyntax" base="BaseFieldDeclarationSyntax"/>
    <class name="EventFieldDeclarationSyntax" base="BaseFieldDeclarationSyntax"/>
    <class name="BaseMethodDeclarationSyntax" abstract="true" base="MemberDeclarationSyntax">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Modifiers" type="Modifier" list="true"/>
        <property name="Parameters" type="ParameterSyntax" list="true" last="true"/>
        <property name="Body" type="BlockSyntax" last="true"/>
    </class>
    <class name="ConstructorDeclarationSyntax" base="BaseMethodDeclarationSyntax">
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <!-- Represents the : this/base call -->
        <property name="Initializer" type="ConstructorInitializerSyntax"/>
    </class>
    <class name="ConstructorInitializerSyntax" base="SyntaxNode">
        <property name="Type" type="ThisOrBase"/>
        <property name="Arguments" type="ArgumentSyntax" list="true"/>
    </class>
    <class name="ConversionOperatorDeclarationSyntax" base="BaseMethodDeclarationSyntax">
        <property name="Type" type="ImplicitOrExplicit"/>
        <property name="TargetType" type="TypeSyntax"/>
    </class>
    <class name="DestructorDeclarationSyntax" base="BaseMethodDeclarationSyntax">
        <property name="Identifier" type="IdentifierNameSyntax"/>
    </class>
    <class name="MethodDeclarationSyntax" base="BaseMethodDeclarationSyntax">
        <property name="ReturnType" type="TypeSyntax"/>
        <property name="ExplicitInterfaceSpecifier" type="NameSyntax" nullable="true"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <property name="TypeParameters" type="TypeParameterSyntax" list="true"/>
        <property name="ConstraintClauses" type="TypeParameterConstraintClauseSyntax" list="true"/>
    </class>
    <class name="OperatorDeclarationSyntax" base="BaseMethodDeclarationSyntax">
        <property name="ReturnType" type="TypeSyntax"/>
        <property name="Operator" type="Operator"/>
    </class>
    <class name="BasePropertyDeclarationSyntax" abstract="true" base="MemberDeclarationSyntax">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Modifiers" type="Modifier" list="true"/>
        <property name="Type" type="TypeSyntax"/>
        <property name="ExplicitInterfaceSpecifier" type="NameSyntax" nullable="true"/>
        <property name="Accessors" type="AccessorDeclarationSyntax" list="true" last="true"/>
    </class>
    <class name="EventDeclarationSyntax" base="BasePropertyDeclarationSyntax">
        <property name="Identifier" type="IdentifierNameSyntax"/>
    </class>
    <class name="IndexerDeclarationSyntax" base="BasePropertyDeclarationSyntax">
        <property name="Parameter" type="ParameterSyntax"/>
    </class>
    <class name="PropertyDeclarationSyntax" base="BasePropertyDeclarationSyntax">
        <property name="Identifier" type="IdentifierNameSyntax"/>
    </class>
    <class name="BaseTypeDeclarationSyntax" abstract="true" base="MemberDeclarationSyntax">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Modifiers" type="Modifier" list="true"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <property name="BaseTypes" type="TypeSyntax" list="true" last="True"/>
    </class>
    <class name="EnumDeclarationSyntax" base="BaseTypeDeclarationSyntax">
        <property name="Members" type="EnumMemberDeclarationSyntax" list="true"/>
    </class>
    <class name="TypeDeclarationSyntax" base="BaseTypeDeclarationSyntax">
        <property name="Type" type="TypeDeclarationType"/>
        <property name="TypeParameters" type="TypeParameterSyntax" list="true"/>
        <property name="ConstraintClauses" type="TypeParameterConstraintClauseSyntax" list="true"/>
        <property name="Members" type="MemberDeclarationSyntax" list="true"/>
    </class>
    <class name="DelegateDeclarationSyntax" base="MemberDeclarationSyntax">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Modifiers" type="Modifier" list="true"/>
        <property name="ReturnType" type="TypeSyntax"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <property name="TypeParameters" type="TypeParameterSyntax" list="true"/>
        <property name="Parameters" type="ParameterSyntax" list="true"/>
        <property name="ConstraintClauses" type="TypeParameterConstraintClauseSyntax" list="true"/>
    </class>
    <class name="EnumMemberDeclarationSyntax" base="MemberDeclarationSyntax">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <property name="Value" type="ExpressionSyntax" nullable="true"/>
    </class>
    <class name="NamespaceDeclarationSyntax" base="MemberDeclarationSyntax">
        <property name="Name" type="NameSyntax"/>
        <property name="Imports" type="ImportDirectiveSyntax" list="true"/>
        <property name="Members" type="MemberDeclarationSyntax" list="true"/>
    </class>
    <class name="ParameterSyntax" base="SyntaxNode">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Modifier" type="ParameterModifier" list="true"/>
        <property name="ParameterType" type="TypeSyntax" nullable="true"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
    </class>
    <class name="StatementSyntax" abstract="true" base="SyntaxNode"/>
    <class name="AssertStatementSyntax" base="StatementSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="BlockSyntax" base="StatementSyntax">
        <property name="Statements" type="StatementSyntax" list="true"/>
    </class>
    <class name="BreakStatementSyntax" base="StatementSyntax"/>
    <class name="ContinueStatementSyntax" base="StatementSyntax"/>
    <class name="DoStatementSyntax" base="StatementSyntax">
        <property name="Condition" type="ExpressionSyntax"/>
        <property name="Block" type="BlockSyntax"/>
    </class>
    <class name="EmptyStatementSyntax" base="StatementSyntax"/>
    <class name="ExpressionStatementSyntax" base="StatementSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="ForEachStatementSyntax" base="StatementSyntax">
        <property name="ElementType" type="TypeSyntax"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Block" type="BlockSyntax"/>
    </class>
    <class name="ForStatementSyntax" base="StatementSyntax">
        <property name="Declaration" type="VariableDeclarationSyntax"/>
        <property name="Initializers" type="ExpressionSyntax" list="true"/>
        <property name="Condition" type="ExpressionSyntax"/>
        <property name="Incrementors" type="ExpressionSyntax" list="true"/>
        <property name="Block" type="BlockSyntax"/>
    </class>
    <class name="IfStatementSyntax" base="StatementSyntax">
        <property name="Condition" type="ExpressionSyntax"/>
        <property name="Block" type="BlockSyntax"/>
        <property name="Elses" type="ElseClauseSyntax" list="true"/>
    </class>
    <class name="ElseClauseSyntax" base="SyntaxNode">
        <property name="Condition" type="ExpressionSyntax" nullable="true"/>
        <property name="Block" type="BlockSyntax"/>
    </class>
    <!-- Represents a variable declaration, but allows final to declare final locals -->
    <class name="LocalDeclarationStatementSyntax" base="StatementSyntax">
        <property name="Modifiers" type="Modifier" list="true"/>
        <property name="Declaration" type="VariableDeclarationSyntax"/>
    </class>
    <class name="ReturnStatementSyntax" base="StatementSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="SwitchStatementSyntax" base="StatementSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Sections" type="SwitchSectionSyntax" list="true"/>
    </class>
    <class name="SwitchSectionSyntax" base="SyntaxNode">
        <property name="Type" type="CaseOrDefault"/>
        <property name="Values" type="ExpressionSyntax" list="true"/>
        <property name="Block" type="BlockSyntax"/>
    </class>
    <class name="ThrowStatementSyntax" base="StatementSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="TryStatementSyntax" base="StatementSyntax">
        <property name="Block" type="BlockSyntax"/>
        <property name="Catches" type="CatchClauseSyntax" list="true"/>
        <property name="Finally" type="FinallyClauseSyntax" nullable="true"/>
    </class>
    <class name="FinallyClauseSyntax" base="SyntaxNode">
        <property name="Block" type="BlockSyntax"/>
    </class>
    <class name="UsingStatementSyntax" base="StatementSyntax">
        <property name="Declaration" type="VariableDeclarationSyntax"/>
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Block" type="BlockSyntax"/>
    </class>
    <class name="LoopStatementSyntax" base="StatementSyntax">
        <property name="Block" type="BlockSyntax"/>
    </class>
    <class name="WhileStatementSyntax" base="StatementSyntax">
        <property name="Condition" type="ExpressionSyntax"/>
        <property name="Block" type="BlockSyntax"/>
    </class>
    <class name="TypeParameterConstraintClauseSyntax" base="SyntaxNode">
        <property name="Name" type="IdentifierNameSyntax"/>
        <property name="Constraints" type="TypeParameterConstraintSyntax" list="true"/>
    </class>
    <class name="TypeParameterConstraintSyntax" abstract="true" base="SyntaxNode"/>
    <class name="ClassOrStructConstraintSyntax" base="TypeParameterConstraintSyntax">
        <property name="Type" type="ClassOrStruct"/>
    </class>
    <class name="ConstructorConstraintSyntax" base="TypeParameterConstraintSyntax"/>
    <class name="TypeConstraintSyntax" base="TypeParameterConstraintSyntax">
        <property name="ConstrainedType" type="TypeSyntax"/>
    </class>
    <class name="TypeParameterSyntax" base="SyntaxNode">
        <property name="AttributeLists" type="AttributeListSyntax" list="true"/>
        <property name="Variance" type="Variance"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
    </class>
    <class name="ImportDirectiveSyntax" base="SyntaxNode">
        <property name="IsStatic" type="boolean"/>
        <property name="Alias" type="IdentifierNameSyntax"/>
        <property name="Name" type="NameSyntax"/>
    </class>
    <class name="VariableDeclarationSyntax" base="SyntaxNode">
        <property name="VariableType" type="TypeSyntax"/>
        <property name="Variables" type="VariableDeclaratorSyntax" list="true"/>
    </class>
    <class name="VariableDeclaratorSyntax" base="SyntaxNode">
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <property name="ArraySizeExpression" type="ExpressionSyntax"/>
        <property name="Value" type="ExpressionSyntax"/>
    </class>
    <enum name="AccessorDeclarationType">
        <!-- This one appears when an illegal keyword is used as the accessor declaration type -->
        <property name="INVALID"/>
        <property name="GET"/>
        <property name="SET"/>
        <property name="ADD"/>
        <property name="REMOVE"/>
    </enum>
    <enum name="AttributeTarget">
        <property name="NONE"/>
        <property name="ASSEMBLY"/>
        <property name="EVENT"/>
        <property name="FIELD"/>
        <property name="METHOD"/>
        <property name="PARAM"/>
        <property name="PROPERTY"/>
        <property name="RETURN"/>
        <property name="TYPE"/>
    </enum>
    <enum name="BinaryOperator">
        <property name="AMPERSAND"/>
        <property name="AMPERSAND_AMPERSAND"/>
        <property name="AMPERSAND_EQUALS"/>
        <property name="AS"/>
        <property name="ASTERISK"/>
        <property name="ASTERISK_EQUALS"/>
        <property name="BAR"/>
        <property name="BAR_BAR"/>
        <property name="BAR_EQUALS"/>
        <property name="CARET"/>
        <property name="CARET_EQUALS"/>
        <property name="EQUALS"/>
        <property name="EQUALS_EQUALS"/>
        <property name="EXCLAMATION_EQUALS"/>
        <property name="GREATER_THAN"/>
        <property name="GREATER_THAN_EQUALS"/>
        <property name="GREATER_THAN_GREATER_THAN"/>
        <property name="GREATER_THAN_GREATER_THAN_EQUALS"/>
        <property name="IS"/>
        <property name="LESS_THAN"/>
        <property name="LESS_THAN_EQUALS"/>
        <property name="LESS_THAN_LESS_THAN"/>
        <property name="LESS_THAN_LESS_THAN_EQUALS"/>
        <property name="MINUS"/>
        <property name="MINUS_EQUALS"/>
        <property name="PERCENT"/>
        <property name="PERCENT_EQUALS"/>
        <property name="PLUS"/>
        <property name="PLUS_EQUALS"/>
        <property name="QUESTION_QUESTION"/>
        <property name="SLASH"/>
        <property name="SLASH_EQUALS"/>
    </enum>
    <enum name="CaseOrDefault">
        <property name="CASE"/>
        <property name="DEFAULT"/>
    </enum>
    <enum name="ClassOrStruct">
        <property name="CLASS"/>
        <property name="STRUCT"/>
    </enum>
    <enum name="ImplicitOrExplicit">
        <property name="EXPLICIT"/>
        <property name="IMPLICIT"/>
    </enum>
    <enum name="LiteralType">
        <property name="CHAR"/>
        <property name="FALSE"/>
        <property name="FLOAT"/>
        <property name="HEX"/>
        <property name="INTEGER"/>
        <property name="NIL"/>
        <property name="STRING"/>
        <property name="TRUE"/>
    </enum>
    <enum name="Modifier">
        <property name="ABSTRACT"/>
        <property name="ASYNC"/>
        <property name="EXTERN"/>
        <property name="INTERNAL"/>
        <property name="NEW"/>
        <property name="OVERRIDE"/>
        <property name="PARTIAL"/>
        <property name="PRIVATE"/>
        <property name="PROTECTED"/>
        <property name="PUBLIC"/>
        <property name="READ_ONLY"/>
        <property name="SEALED"/>
        <property name="STATIC"/>
        <property name="VIRTUAL"/>
        <property name="VOLATILE"/>
    </enum>
    <enum name="NakedNullableType">
        <property name="NULLABLE"/>
        <property name="NOT_NULLABLE"/>
    </enum>
    <enum name="Operator">
        <property name="AMPERSAND"/>
        <property name="ASTERISK"/>
        <property name="BAR"/>
        <property name="CARET"/>
        <property name="EQUALS_EQUALS"/>
        <property name="EXCLAMATION"/>
        <property name="EXCLAMATION_EQUALS"/>
        <property name="FALSE"/>
        <property name="GREATER_THAN"/>
        <property name="GREATER_THAN_EQUALS"/>
        <property name="GREATER_THAN_GREATER_THAN"/>
        <property name="LESS_THAN"/>
        <property name="LESS_THAN_EQUALS"/>
        <property name="LESS_THAN_LESS_THAN"/>
        <property name="MINUS"/>
        <property name="MINUS_MINUS"/>
        <property name="PERCENT"/>
        <property name="PLUS"/>
        <property name="PLUS_PLUS"/>
        <property name="SLASH"/>
        <property name="TILDE"/>
        <property name="TRUE"/>
    </enum>
    <enum name="ParameterModifier">
        <property name="THIS"/>
        <property name="REF"/>
        <property name="OUT"/>
        <property name="PARAMS"/>
    </enum>
    <enum name="PostfixUnaryOperator">
        <property name="MINUS_MINUS"/>
        <property name="PLUS_PLUS"/>
    </enum>
    <enum name="PredefinedType">
        <property name="BOOL"/>
        <property name="BYTE"/>
        <property name="CHAR"/>
        <property name="DECIMAL"/>
        <property name="DOUBLE"/>
        <property name="FLOAT"/>
        <property name="INT"/>
        <property name="LONG"/>
        <property name="OBJECT"/>
        <property name="SBYTE"/>
        <property name="SHORT"/>
        <property name="STRING"/>
        <property name="UINT"/>
        <property name="ULONG"/>
        <property name="USHORT"/>
        <property name="VOID"/>
    </enum>
    <enum name="PrefixUnaryOperator">
        <property name="AMPERSAND"/>
        <property name="EXCLAMATION"/>
        <property name="MINUS"/>
        <property name="MINUS_MINUS"/>
        <property name="PLUS"/>
        <property name="PLUS_PLUS"/>
        <property name="TILDE"/>
    </enum>
    <enum name="ThisOrBase">
        <property name="BASE"/>
        <property name="THIS"/>
    </enum>
    <enum name="TypeDeclarationType">
        <property name="CLASS"/>
        <property name="INTERFACE"/>
        <property name="STRUCT"/>
    </enum>
    <enum name="Variance">
        <property name="NONE"/>
        <property name="IN"/>
        <property name="OUT"/>
    </enum>
    <!-- Disabled functionality. For the things below, I'm not really determined yet to exclude them. Probably will though -->
    <!-- Checked
    <class name="CheckedExpressionSyntax" base="ExpressionSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Type" type="CheckedOrUnchecked"/>
    </class>
    <class name="CheckedStatementSyntax" base="StatementSyntax">
        <property name="Block" type="BlockSyntax"/>
        <property name="Type" type="CheckedOrUnchecked"/>
    </class>
    <enum name="CheckedOrUnchecked">
        <property name="CHECKED"/>
        <property name="UNCHECKED"/>
    </enum>
    -->
    <!-- Generator
    <class name="YieldStatementSyntax" base="StatementSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Type" type="ReturnOrBreak"/>
    </class>
    <enum name="ReturnOrBreak">
        <property name="BREAK"/>
        <property name="RETURN"/>
    </enum>
    -->
    <!-- LINQ
    <class name="JoinIntoClauseSyntax" base="SyntaxNode">
        <property name="Identifier" type="IdentifierNameSyntax"/>
    </class>
    <class name="QueryExpressionSyntax" base="ExpressionSyntax">
        <property name="Body" type="QueryBodySyntax"/>
        <property name="FromClause" type="FromClauseSyntax"/>
    </class>
    <class name="OrderingSyntax" base="SyntaxNode">
        <property name="Type" type="AscendingOrDescending"/>
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="QueryBodySyntax" base="SyntaxNode">
        <property name="Clauses" type="QueryClauseSyntax" list="true"/>
        <property name="Continuation" type="QueryContinuationSyntax"/>
        <property name="SelectOrGroup" type="SelectOrGroupClauseSyntax"/>
    </class>
    <class name="QueryClauseSyntax" abstract="true" base="SyntaxNode"/>
    <class name="FromClauseSyntax" base="QueryClauseSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <property name="Type" type="TypeSyntax"/>
    </class>
    <class name="JoinClauseSyntax" base="QueryClauseSyntax">
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <property name="InExpression" type="ExpressionSyntax"/>
        <property name="Into" type="JoinIntoClauseSyntax"/>
        <property name="LeftExpression" type="ExpressionSyntax"/>
        <property name="RightExpression" type="ExpressionSyntax"/>
        <property name="Type" type="TypeSyntax"/>
    </class>
    <class name="LetClauseSyntax" base="QueryClauseSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
    </class>
    <class name="OrderByClauseSyntax" base="QueryClauseSyntax">
        <property name="Orderings" type="OrderingSyntax" list="true"/>
    </class>
    <class name="WhereClauseSyntax" base="QueryClauseSyntax">
        <property name="Condition" type="ExpressionSyntax"/>
    </class>
    <class name="QueryContinuationSyntax" base="SyntaxNode">
        <property name="Body" type="QueryBodySyntax"/>
        <property name="Identifier" type="IdentifierNameSyntax"/>
    </class>
    <class name="SelectOrGroupClauseSyntax" abstract="true" base="SyntaxNode"/>
    <class name="GroupClauseSyntax" base="SelectOrGroupClauseSyntax">
        <property name="ByExpression" type="ExpressionSyntax"/>
        <property name="GroupExpression" type="ExpressionSyntax"/>
    </class>
    <class name="SelectClauseSyntax" base="SelectOrGroupClauseSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <enum name="AscendingOrDescending">
        <property name="ASCENDING"/>
        <property name="DESCENDING"/>
    </enum>
    -->
    <!-- Goto/label
    <class name="GotoStatementSyntax" base="StatementSyntax">
        <property name="Type" type="CaseOrDefault"/>
        <property name="Expression" type="ExpressionSyntax"/>
    </class>
    <class name="LabeledStatementSyntax" base="StatementSyntax">
        <property name="Identifier" type="IdentifierNameSyntax"/>
        <property name="Statement" type="StatementSyntax"/>
    </class>
    -->
    <!-- Lock
    <class name="LockStatementSyntax" base="StatementSyntax">
        <property name="Expression" type="ExpressionSyntax"/>
        <property name="Statement" type="StatementSyntax"/>
    </class>
    -->
</schema>