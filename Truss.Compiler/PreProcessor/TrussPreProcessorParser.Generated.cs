//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 TrussPreProcessor.g 2014-06-20 08:55:06

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  Truss.Compiler.PreProcessor 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
 internal  partial class TrussPreProcessorParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "DIGIT", "FIRST_LETTER", "IDENTIFIER", "KW_DEFINE", "KW_ELIF", "KW_ELSE", "KW_ENDIF", "KW_FALSE", "KW_IF", "KW_TRUE", "KW_UNDEF", "LETTER", "NEXT_LETTER", "OP_AMPERSAND_AMPERSAND", "OP_BAR_BAR", "OP_EQUALS_EQUALS", "OP_EXCLAMATION", "OP_EXCLAMATION_EQUALS", "OP_PAREN_CLOSE", "OP_PAREN_OPEN", "WS"
	};
	public const int EOF=-1;
	public const int DIGIT=4;
	public const int FIRST_LETTER=5;
	public const int IDENTIFIER=6;
	public const int KW_DEFINE=7;
	public const int KW_ELIF=8;
	public const int KW_ELSE=9;
	public const int KW_ENDIF=10;
	public const int KW_FALSE=11;
	public const int KW_IF=12;
	public const int KW_TRUE=13;
	public const int KW_UNDEF=14;
	public const int LETTER=15;
	public const int NEXT_LETTER=16;
	public const int OP_AMPERSAND_AMPERSAND=17;
	public const int OP_BAR_BAR=18;
	public const int OP_EQUALS_EQUALS=19;
	public const int OP_EXCLAMATION=20;
	public const int OP_EXCLAMATION_EQUALS=21;
	public const int OP_PAREN_CLOSE=22;
	public const int OP_PAREN_OPEN=23;
	public const int WS=24;

	public TrussPreProcessorParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TrussPreProcessorParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return TrussPreProcessorParser.tokenNames; } }
	public override string GrammarFileName { get { return "TrussPreProcessor.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_directive();
	partial void LeaveRule_directive();
	// $ANTLR start "directive"
	// TrussPreProcessor.g:17:1: directive returns [IDirective value] : ( WS )* (e1= ifDirective |e2= elIfDirective |e3= elseDirective |e4= endIfDirective |e5= defineDirective |e6= undefDirective ) EOF ;
	[GrammarRule("directive")]
	private IDirective directive()
	{
		EnterRule_directive();
		EnterRule("directive", 1);
		TraceIn("directive", 1);
		IDirective value = default(IDirective);


		IfDirective e1 = default(IfDirective);
		ElIfDirective e2 = default(ElIfDirective);
		ElseDirective e3 = default(ElseDirective);
		EndIfDirective e4 = default(EndIfDirective);
		DefineDirective e5 = default(DefineDirective);
		DefineDirective e6 = default(DefineDirective);

		try { DebugEnterRule(GrammarFileName, "directive");
		DebugLocation(17, 4);
		try
		{
			// TrussPreProcessor.g:18:5: ( ( WS )* (e1= ifDirective |e2= elIfDirective |e3= elseDirective |e4= endIfDirective |e5= defineDirective |e6= undefDirective ) EOF )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:19:9: ( WS )* (e1= ifDirective |e2= elIfDirective |e3= elseDirective |e4= endIfDirective |e5= defineDirective |e6= undefDirective ) EOF
			{
			DebugLocation(19, 9);
			// TrussPreProcessor.g:19:9: ( WS )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==WS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// TrussPreProcessor.g:19:9: WS
					{
					DebugLocation(19, 9);
					Match(input,WS,Follow._WS_in_directive87); if (state.failed) return value;

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(20, 9);
			// TrussPreProcessor.g:20:9: (e1= ifDirective |e2= elIfDirective |e3= elseDirective |e4= endIfDirective |e5= defineDirective |e6= undefDirective )
			int alt2=6;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case KW_IF:
				{
				alt2 = 1;
				}
				break;
			case KW_ELIF:
				{
				alt2 = 2;
				}
				break;
			case KW_ELSE:
				{
				alt2 = 3;
				}
				break;
			case KW_ENDIF:
				{
				alt2 = 4;
				}
				break;
			case KW_DEFINE:
				{
				alt2 = 5;
				}
				break;
			case KW_UNDEF:
				{
				alt2 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// TrussPreProcessor.g:20:11: e1= ifDirective
				{
				DebugLocation(20, 13);
				PushFollow(Follow._ifDirective_in_directive102);
				e1=ifDirective();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(20, 26);
				if (state.backtracking == 0)
				{
					 value = e1; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TrussPreProcessor.g:21:11: e2= elIfDirective
				{
				DebugLocation(21, 13);
				PushFollow(Follow._elIfDirective_in_directive118);
				e2=elIfDirective();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(21, 28);
				if (state.backtracking == 0)
				{
					 value = e2; 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TrussPreProcessor.g:22:11: e3= elseDirective
				{
				DebugLocation(22, 13);
				PushFollow(Follow._elseDirective_in_directive134);
				e3=elseDirective();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(22, 28);
				if (state.backtracking == 0)
				{
					 value = e3; 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TrussPreProcessor.g:23:11: e4= endIfDirective
				{
				DebugLocation(23, 13);
				PushFollow(Follow._endIfDirective_in_directive150);
				e4=endIfDirective();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(23, 29);
				if (state.backtracking == 0)
				{
					 value = e4; 
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// TrussPreProcessor.g:24:11: e5= defineDirective
				{
				DebugLocation(24, 13);
				PushFollow(Follow._defineDirective_in_directive166);
				e5=defineDirective();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(24, 30);
				if (state.backtracking == 0)
				{
					 value = e5; 
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// TrussPreProcessor.g:25:11: e6= undefDirective
				{
				DebugLocation(25, 13);
				PushFollow(Follow._undefDirective_in_directive182);
				e6=undefDirective();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(25, 29);
				if (state.backtracking == 0)
				{
					 value = e6; 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(27, 9);
			Match(input,EOF,Follow._EOF_in_directive204); if (state.failed) return value;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("directive", 1);
			LeaveRule("directive", 1);
			LeaveRule_directive();
		}
		DebugLocation(28, 4);
		} finally { DebugExitRule(GrammarFileName, "directive"); }
		return value;

	}
	// $ANTLR end "directive"

	partial void EnterRule_ifDirective();
	partial void LeaveRule_ifDirective();
	// $ANTLR start "ifDirective"
	// TrussPreProcessor.g:30:1: ifDirective returns [IfDirective value] : KW_IF e= expression ;
	[GrammarRule("ifDirective")]
	private IfDirective ifDirective()
	{
		EnterRule_ifDirective();
		EnterRule("ifDirective", 2);
		TraceIn("ifDirective", 2);
		IfDirective value = default(IfDirective);


		bool e = default(bool);

		try { DebugEnterRule(GrammarFileName, "ifDirective");
		DebugLocation(30, 4);
		try
		{
			// TrussPreProcessor.g:31:5: ( KW_IF e= expression )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:32:9: KW_IF e= expression
			{
			DebugLocation(32, 9);
			Match(input,KW_IF,Follow._KW_IF_in_ifDirective233); if (state.failed) return value;
			DebugLocation(33, 10);
			PushFollow(Follow._expression_in_ifDirective245);
			e=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(34, 9);
			if (state.backtracking == 0)
			{
				 value = new IfDirective(e); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ifDirective", 2);
			LeaveRule("ifDirective", 2);
			LeaveRule_ifDirective();
		}
		DebugLocation(35, 4);
		} finally { DebugExitRule(GrammarFileName, "ifDirective"); }
		return value;

	}
	// $ANTLR end "ifDirective"

	partial void EnterRule_elIfDirective();
	partial void LeaveRule_elIfDirective();
	// $ANTLR start "elIfDirective"
	// TrussPreProcessor.g:37:1: elIfDirective returns [ElIfDirective value] : KW_ELIF e= expression ;
	[GrammarRule("elIfDirective")]
	private ElIfDirective elIfDirective()
	{
		EnterRule_elIfDirective();
		EnterRule("elIfDirective", 3);
		TraceIn("elIfDirective", 3);
		ElIfDirective value = default(ElIfDirective);


		bool e = default(bool);

		try { DebugEnterRule(GrammarFileName, "elIfDirective");
		DebugLocation(37, 4);
		try
		{
			// TrussPreProcessor.g:38:5: ( KW_ELIF e= expression )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:39:9: KW_ELIF e= expression
			{
			DebugLocation(39, 9);
			Match(input,KW_ELIF,Follow._KW_ELIF_in_elIfDirective284); if (state.failed) return value;
			DebugLocation(40, 10);
			PushFollow(Follow._expression_in_elIfDirective296);
			e=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(41, 9);
			if (state.backtracking == 0)
			{
				 value = new ElIfDirective(e); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("elIfDirective", 3);
			LeaveRule("elIfDirective", 3);
			LeaveRule_elIfDirective();
		}
		DebugLocation(42, 4);
		} finally { DebugExitRule(GrammarFileName, "elIfDirective"); }
		return value;

	}
	// $ANTLR end "elIfDirective"

	partial void EnterRule_elseDirective();
	partial void LeaveRule_elseDirective();
	// $ANTLR start "elseDirective"
	// TrussPreProcessor.g:44:1: elseDirective returns [ElseDirective value] : KW_ELSE ;
	[GrammarRule("elseDirective")]
	private ElseDirective elseDirective()
	{
		EnterRule_elseDirective();
		EnterRule("elseDirective", 4);
		TraceIn("elseDirective", 4);
		ElseDirective value = default(ElseDirective);


		try { DebugEnterRule(GrammarFileName, "elseDirective");
		DebugLocation(44, 4);
		try
		{
			// TrussPreProcessor.g:45:5: ( KW_ELSE )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:46:9: KW_ELSE
			{
			DebugLocation(46, 9);
			Match(input,KW_ELSE,Follow._KW_ELSE_in_elseDirective335); if (state.failed) return value;
			DebugLocation(47, 9);
			if (state.backtracking == 0)
			{
				 value = new ElseDirective(); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("elseDirective", 4);
			LeaveRule("elseDirective", 4);
			LeaveRule_elseDirective();
		}
		DebugLocation(48, 4);
		} finally { DebugExitRule(GrammarFileName, "elseDirective"); }
		return value;

	}
	// $ANTLR end "elseDirective"

	partial void EnterRule_endIfDirective();
	partial void LeaveRule_endIfDirective();
	// $ANTLR start "endIfDirective"
	// TrussPreProcessor.g:50:1: endIfDirective returns [EndIfDirective value] : KW_ENDIF ;
	[GrammarRule("endIfDirective")]
	private EndIfDirective endIfDirective()
	{
		EnterRule_endIfDirective();
		EnterRule("endIfDirective", 5);
		TraceIn("endIfDirective", 5);
		EndIfDirective value = default(EndIfDirective);


		try { DebugEnterRule(GrammarFileName, "endIfDirective");
		DebugLocation(50, 4);
		try
		{
			// TrussPreProcessor.g:51:5: ( KW_ENDIF )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:52:9: KW_ENDIF
			{
			DebugLocation(52, 9);
			Match(input,KW_ENDIF,Follow._KW_ENDIF_in_endIfDirective374); if (state.failed) return value;
			DebugLocation(53, 9);
			if (state.backtracking == 0)
			{
				 value = new EndIfDirective(); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("endIfDirective", 5);
			LeaveRule("endIfDirective", 5);
			LeaveRule_endIfDirective();
		}
		DebugLocation(54, 4);
		} finally { DebugExitRule(GrammarFileName, "endIfDirective"); }
		return value;

	}
	// $ANTLR end "endIfDirective"

	partial void EnterRule_defineDirective();
	partial void LeaveRule_defineDirective();
	// $ANTLR start "defineDirective"
	// TrussPreProcessor.g:56:1: defineDirective returns [DefineDirective value] : KW_DEFINE i= IDENTIFIER ;
	[GrammarRule("defineDirective")]
	private DefineDirective defineDirective()
	{
		EnterRule_defineDirective();
		EnterRule("defineDirective", 6);
		TraceIn("defineDirective", 6);
		DefineDirective value = default(DefineDirective);


		IToken i = default(IToken);

		try { DebugEnterRule(GrammarFileName, "defineDirective");
		DebugLocation(56, 4);
		try
		{
			// TrussPreProcessor.g:57:5: ( KW_DEFINE i= IDENTIFIER )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:58:9: KW_DEFINE i= IDENTIFIER
			{
			DebugLocation(58, 9);
			Match(input,KW_DEFINE,Follow._KW_DEFINE_in_defineDirective413); if (state.failed) return value;
			DebugLocation(59, 10);
			i=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_defineDirective425); if (state.failed) return value;
			DebugLocation(60, 9);
			if (state.backtracking == 0)
			{
				 value = new DefineDirective(i.Text, true); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("defineDirective", 6);
			LeaveRule("defineDirective", 6);
			LeaveRule_defineDirective();
		}
		DebugLocation(61, 4);
		} finally { DebugExitRule(GrammarFileName, "defineDirective"); }
		return value;

	}
	// $ANTLR end "defineDirective"

	partial void EnterRule_undefDirective();
	partial void LeaveRule_undefDirective();
	// $ANTLR start "undefDirective"
	// TrussPreProcessor.g:63:1: undefDirective returns [DefineDirective value] : KW_UNDEF i= IDENTIFIER ;
	[GrammarRule("undefDirective")]
	private DefineDirective undefDirective()
	{
		EnterRule_undefDirective();
		EnterRule("undefDirective", 7);
		TraceIn("undefDirective", 7);
		DefineDirective value = default(DefineDirective);


		IToken i = default(IToken);

		try { DebugEnterRule(GrammarFileName, "undefDirective");
		DebugLocation(63, 4);
		try
		{
			// TrussPreProcessor.g:64:5: ( KW_UNDEF i= IDENTIFIER )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:65:9: KW_UNDEF i= IDENTIFIER
			{
			DebugLocation(65, 9);
			Match(input,KW_UNDEF,Follow._KW_UNDEF_in_undefDirective464); if (state.failed) return value;
			DebugLocation(66, 10);
			i=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_undefDirective476); if (state.failed) return value;
			DebugLocation(67, 9);
			if (state.backtracking == 0)
			{
				 value = new DefineDirective(i.Text, false); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("undefDirective", 7);
			LeaveRule("undefDirective", 7);
			LeaveRule_undefDirective();
		}
		DebugLocation(68, 4);
		} finally { DebugExitRule(GrammarFileName, "undefDirective"); }
		return value;

	}
	// $ANTLR end "undefDirective"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// TrussPreProcessor.g:70:1: expression returns [bool value] : oe= orExpression ;
	[GrammarRule("expression")]
	private bool expression()
	{
		EnterRule_expression();
		EnterRule("expression", 8);
		TraceIn("expression", 8);
		bool value = default(bool);


		bool oe = default(bool);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(70, 4);
		try
		{
			// TrussPreProcessor.g:71:5: (oe= orExpression )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:72:9: oe= orExpression
			{
			DebugLocation(72, 11);
			PushFollow(Follow._orExpression_in_expression517);
			oe=orExpression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(72, 25);
			if (state.backtracking == 0)
			{
				 value = oe; 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 8);
			LeaveRule("expression", 8);
			LeaveRule_expression();
		}
		DebugLocation(73, 4);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return value;

	}
	// $ANTLR end "expression"

	partial void EnterRule_orExpression();
	partial void LeaveRule_orExpression();
	// $ANTLR start "orExpression"
	// TrussPreProcessor.g:75:1: orExpression returns [bool value] : ae= andExpression ( OP_BAR_BAR ae= andExpression )* ;
	[GrammarRule("orExpression")]
	private bool orExpression()
	{
		EnterRule_orExpression();
		EnterRule("orExpression", 9);
		TraceIn("orExpression", 9);
		bool value = default(bool);


		bool ae = default(bool);

		try { DebugEnterRule(GrammarFileName, "orExpression");
		DebugLocation(75, 4);
		try
		{
			// TrussPreProcessor.g:76:5: (ae= andExpression ( OP_BAR_BAR ae= andExpression )* )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:77:9: ae= andExpression ( OP_BAR_BAR ae= andExpression )*
			{
			DebugLocation(77, 11);
			PushFollow(Follow._andExpression_in_orExpression550);
			ae=andExpression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(77, 26);
			if (state.backtracking == 0)
			{
				 value = ae; 
			}
			DebugLocation(78, 9);
			// TrussPreProcessor.g:78:9: ( OP_BAR_BAR ae= andExpression )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==OP_BAR_BAR))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// TrussPreProcessor.g:79:13: OP_BAR_BAR ae= andExpression
					{
					DebugLocation(79, 13);
					Match(input,OP_BAR_BAR,Follow._OP_BAR_BAR_in_orExpression576); if (state.failed) return value;
					DebugLocation(80, 15);
					PushFollow(Follow._andExpression_in_orExpression592);
					ae=andExpression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(80, 30);
					if (state.backtracking == 0)
					{
						 value = value || ae; 
					}

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("orExpression", 9);
			LeaveRule("orExpression", 9);
			LeaveRule_orExpression();
		}
		DebugLocation(82, 4);
		} finally { DebugExitRule(GrammarFileName, "orExpression"); }
		return value;

	}
	// $ANTLR end "orExpression"

	partial void EnterRule_andExpression();
	partial void LeaveRule_andExpression();
	// $ANTLR start "andExpression"
	// TrussPreProcessor.g:84:1: andExpression returns [bool value] : ee= equalityExpression ( OP_AMPERSAND_AMPERSAND ee= equalityExpression )* ;
	[GrammarRule("andExpression")]
	private bool andExpression()
	{
		EnterRule_andExpression();
		EnterRule("andExpression", 10);
		TraceIn("andExpression", 10);
		bool value = default(bool);


		bool ee = default(bool);

		try { DebugEnterRule(GrammarFileName, "andExpression");
		DebugLocation(84, 4);
		try
		{
			// TrussPreProcessor.g:85:5: (ee= equalityExpression ( OP_AMPERSAND_AMPERSAND ee= equalityExpression )* )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:86:9: ee= equalityExpression ( OP_AMPERSAND_AMPERSAND ee= equalityExpression )*
			{
			DebugLocation(86, 11);
			PushFollow(Follow._equalityExpression_in_andExpression636);
			ee=equalityExpression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(86, 31);
			if (state.backtracking == 0)
			{
				 value = ee; 
			}
			DebugLocation(87, 9);
			// TrussPreProcessor.g:87:9: ( OP_AMPERSAND_AMPERSAND ee= equalityExpression )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==OP_AMPERSAND_AMPERSAND))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// TrussPreProcessor.g:88:13: OP_AMPERSAND_AMPERSAND ee= equalityExpression
					{
					DebugLocation(88, 13);
					Match(input,OP_AMPERSAND_AMPERSAND,Follow._OP_AMPERSAND_AMPERSAND_in_andExpression662); if (state.failed) return value;
					DebugLocation(89, 15);
					PushFollow(Follow._equalityExpression_in_andExpression678);
					ee=equalityExpression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(89, 35);
					if (state.backtracking == 0)
					{
						 value = value && ee; 
					}

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("andExpression", 10);
			LeaveRule("andExpression", 10);
			LeaveRule_andExpression();
		}
		DebugLocation(91, 4);
		} finally { DebugExitRule(GrammarFileName, "andExpression"); }
		return value;

	}
	// $ANTLR end "andExpression"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// TrussPreProcessor.g:93:1: equalityExpression returns [bool value] : ue= unaryExpression ( ( OP_EQUALS_EQUALS | OP_EXCLAMATION_EQUALS ) ue= unaryExpression )* ;
	[GrammarRule("equalityExpression")]
	private bool equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 11);
		TraceIn("equalityExpression", 11);
		bool value = default(bool);


		bool ue = default(bool);


		    bool isNotEquals = false;

		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(93, 4);
		try
		{
			// TrussPreProcessor.g:97:5: (ue= unaryExpression ( ( OP_EQUALS_EQUALS | OP_EXCLAMATION_EQUALS ) ue= unaryExpression )* )
			DebugEnterAlt(1);
			// TrussPreProcessor.g:98:9: ue= unaryExpression ( ( OP_EQUALS_EQUALS | OP_EXCLAMATION_EQUALS ) ue= unaryExpression )*
			{
			DebugLocation(98, 11);
			PushFollow(Follow._unaryExpression_in_equalityExpression727);
			ue=unaryExpression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(98, 28);
			if (state.backtracking == 0)
			{
				 value = ue; 
			}
			DebugLocation(99, 9);
			// TrussPreProcessor.g:99:9: ( ( OP_EQUALS_EQUALS | OP_EXCLAMATION_EQUALS ) ue= unaryExpression )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==OP_EQUALS_EQUALS||LA6_1==OP_EXCLAMATION_EQUALS))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// TrussPreProcessor.g:100:13: ( OP_EQUALS_EQUALS | OP_EXCLAMATION_EQUALS ) ue= unaryExpression
					{
					DebugLocation(100, 13);
					// TrussPreProcessor.g:100:13: ( OP_EQUALS_EQUALS | OP_EXCLAMATION_EQUALS )
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1==OP_EQUALS_EQUALS))
					{
						alt5 = 1;
					}
					else if ((LA5_1==OP_EXCLAMATION_EQUALS))
					{
						alt5 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// TrussPreProcessor.g:101:17: OP_EQUALS_EQUALS
						{
						DebugLocation(101, 17);
						Match(input,OP_EQUALS_EQUALS,Follow._OP_EQUALS_EQUALS_in_equalityExpression771); if (state.failed) return value;
						DebugLocation(101, 34);
						if (state.backtracking == 0)
						{
							 isNotEquals = false; 
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// TrussPreProcessor.g:103:17: OP_EXCLAMATION_EQUALS
						{
						DebugLocation(103, 17);
						Match(input,OP_EXCLAMATION_EQUALS,Follow._OP_EXCLAMATION_EQUALS_in_equalityExpression805); if (state.failed) return value;
						DebugLocation(103, 39);
						if (state.backtracking == 0)
						{
							 isNotEquals = true; 
						}

						}
						break;

					}
					} finally { DebugExitSubRule(5); }

					DebugLocation(105, 15);
					PushFollow(Follow._unaryExpression_in_equalityExpression837);
					ue=unaryExpression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(106, 13);
					if (state.backtracking == 0)
					{

						                if (isNotEquals) {
						                    value = value != ue;
						                } else {
						                    value = value == ue;
						                }
						            
					}

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("equalityExpression", 11);
			LeaveRule("equalityExpression", 11);
			LeaveRule_equalityExpression();
		}
		DebugLocation(114, 4);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return value;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// TrussPreProcessor.g:116:1: unaryExpression returns [bool value] : (pe= primaryExpression | OP_EXCLAMATION ue= unaryExpression );
	[GrammarRule("unaryExpression")]
	private bool unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 12);
		TraceIn("unaryExpression", 12);
		bool value = default(bool);


		bool pe = default(bool);
		bool ue = default(bool);

		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(116, 4);
		try
		{
			// TrussPreProcessor.g:117:5: (pe= primaryExpression | OP_EXCLAMATION ue= unaryExpression )
			int alt7=2;
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==IDENTIFIER||LA7_1==KW_FALSE||LA7_1==KW_TRUE||LA7_1==OP_PAREN_OPEN))
			{
				alt7 = 1;
			}
			else if ((LA7_1==OP_EXCLAMATION))
			{
				alt7 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// TrussPreProcessor.g:118:9: pe= primaryExpression
				{
				DebugLocation(118, 11);
				PushFollow(Follow._primaryExpression_in_unaryExpression893);
				pe=primaryExpression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(118, 30);
				if (state.backtracking == 0)
				{
					 value = pe; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TrussPreProcessor.g:120:9: OP_EXCLAMATION ue= unaryExpression
				{
				DebugLocation(120, 9);
				Match(input,OP_EXCLAMATION,Follow._OP_EXCLAMATION_in_unaryExpression911); if (state.failed) return value;
				DebugLocation(121, 11);
				PushFollow(Follow._unaryExpression_in_unaryExpression923);
				ue=unaryExpression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(121, 28);
				if (state.backtracking == 0)
				{
					 value = !ue; 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("unaryExpression", 12);
			LeaveRule("unaryExpression", 12);
			LeaveRule_unaryExpression();
		}
		DebugLocation(122, 4);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return value;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// TrussPreProcessor.g:124:1: primaryExpression returns [bool value] : ( KW_TRUE | KW_FALSE |i= IDENTIFIER | OP_PAREN_OPEN e= expression OP_PAREN_CLOSE );
	[GrammarRule("primaryExpression")]
	private bool primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 13);
		TraceIn("primaryExpression", 13);
		bool value = default(bool);


		IToken i = default(IToken);
		bool e = default(bool);

		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(124, 4);
		try
		{
			// TrussPreProcessor.g:125:5: ( KW_TRUE | KW_FALSE |i= IDENTIFIER | OP_PAREN_OPEN e= expression OP_PAREN_CLOSE )
			int alt8=4;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case KW_TRUE:
				{
				alt8 = 1;
				}
				break;
			case KW_FALSE:
				{
				alt8 = 2;
				}
				break;
			case IDENTIFIER:
				{
				alt8 = 3;
				}
				break;
			case OP_PAREN_OPEN:
				{
				alt8 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// TrussPreProcessor.g:126:9: KW_TRUE
				{
				DebugLocation(126, 9);
				Match(input,KW_TRUE,Follow._KW_TRUE_in_primaryExpression954); if (state.failed) return value;
				DebugLocation(126, 17);
				if (state.backtracking == 0)
				{
					 value = true; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// TrussPreProcessor.g:128:9: KW_FALSE
				{
				DebugLocation(128, 9);
				Match(input,KW_FALSE,Follow._KW_FALSE_in_primaryExpression972); if (state.failed) return value;
				DebugLocation(128, 18);
				if (state.backtracking == 0)
				{
					 value = false; 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// TrussPreProcessor.g:130:9: i= IDENTIFIER
				{
				DebugLocation(130, 10);
				i=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_primaryExpression992); if (state.failed) return value;
				DebugLocation(130, 22);
				if (state.backtracking == 0)
				{
					 value = IsDefined(i.Text); 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// TrussPreProcessor.g:132:9: OP_PAREN_OPEN e= expression OP_PAREN_CLOSE
				{
				DebugLocation(132, 9);
				Match(input,OP_PAREN_OPEN,Follow._OP_PAREN_OPEN_in_primaryExpression1010); if (state.failed) return value;
				DebugLocation(132, 24);
				PushFollow(Follow._expression_in_primaryExpression1014);
				e=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(132, 36);
				Match(input,OP_PAREN_CLOSE,Follow._OP_PAREN_CLOSE_in_primaryExpression1016); if (state.failed) return value;
				DebugLocation(132, 51);
				if (state.backtracking == 0)
				{
					 value = e; 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("primaryExpression", 13);
			LeaveRule("primaryExpression", 13);
			LeaveRule_primaryExpression();
		}
		DebugLocation(133, 4);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return value;

	}
	// $ANTLR end "primaryExpression"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _WS_in_directive87 = new BitSet(new ulong[]{0x1005780UL});
		public static readonly BitSet _ifDirective_in_directive102 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _elIfDirective_in_directive118 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _elseDirective_in_directive134 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _endIfDirective_in_directive150 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _defineDirective_in_directive166 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _undefDirective_in_directive182 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_directive204 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _KW_IF_in_ifDirective233 = new BitSet(new ulong[]{0x902840UL});
		public static readonly BitSet _expression_in_ifDirective245 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _KW_ELIF_in_elIfDirective284 = new BitSet(new ulong[]{0x902840UL});
		public static readonly BitSet _expression_in_elIfDirective296 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _KW_ELSE_in_elseDirective335 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _KW_ENDIF_in_endIfDirective374 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _KW_DEFINE_in_defineDirective413 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _IDENTIFIER_in_defineDirective425 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _KW_UNDEF_in_undefDirective464 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _IDENTIFIER_in_undefDirective476 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _orExpression_in_expression517 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _andExpression_in_orExpression550 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _OP_BAR_BAR_in_orExpression576 = new BitSet(new ulong[]{0x902840UL});
		public static readonly BitSet _andExpression_in_orExpression592 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _equalityExpression_in_andExpression636 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _OP_AMPERSAND_AMPERSAND_in_andExpression662 = new BitSet(new ulong[]{0x902840UL});
		public static readonly BitSet _equalityExpression_in_andExpression678 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _unaryExpression_in_equalityExpression727 = new BitSet(new ulong[]{0x280002UL});
		public static readonly BitSet _OP_EQUALS_EQUALS_in_equalityExpression771 = new BitSet(new ulong[]{0x902840UL});
		public static readonly BitSet _OP_EXCLAMATION_EQUALS_in_equalityExpression805 = new BitSet(new ulong[]{0x902840UL});
		public static readonly BitSet _unaryExpression_in_equalityExpression837 = new BitSet(new ulong[]{0x280002UL});
		public static readonly BitSet _primaryExpression_in_unaryExpression893 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_EXCLAMATION_in_unaryExpression911 = new BitSet(new ulong[]{0x902840UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression923 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _KW_TRUE_in_primaryExpression954 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _KW_FALSE_in_primaryExpression972 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_primaryExpression992 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_PAREN_OPEN_in_primaryExpression1010 = new BitSet(new ulong[]{0x902840UL});
		public static readonly BitSet _expression_in_primaryExpression1014 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _OP_PAREN_CLOSE_in_primaryExpression1016 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Truss.Compiler.PreProcessor 
