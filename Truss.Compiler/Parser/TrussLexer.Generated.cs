//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 Truss.g 2014-06-20 09:29:58

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


    using Truss.Compiler;
    using Truss.Compiler.Syntax;
    using Truss.Compiler.Support;
    using System.Diagnostics;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  Truss.Compiler.Parser 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
 internal  partial class TrussLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int BLOCK_COMMENT=4;
	public const int CHAR=5;
	public const int DIGIT=6;
	public const int EXPONENT=7;
	public const int FLOAT=8;
	public const int FLOAT_SUFFIX=9;
	public const int HEX_DIGIT=10;
	public const int HEX_INTEGER=11;
	public const int IDENTIFIER=12;
	public const int IDENTIFIER_CHARACTER=13;
	public const int IDENTIFIER_FIRST_CHARACTER=14;
	public const int INPUT_CHARACTER=15;
	public const int INTEGER=16;
	public const int INTEGER_SUFFIX=17;
	public const int KW_ABSTRACT=18;
	public const int KW_AS=19;
	public const int KW_ASSERT=20;
	public const int KW_ASYNC=21;
	public const int KW_AWAIT=22;
	public const int KW_BASE=23;
	public const int KW_BOOL=24;
	public const int KW_BREAK=25;
	public const int KW_BYTE=26;
	public const int KW_CASE=27;
	public const int KW_CATCH=28;
	public const int KW_CHAR=29;
	public const int KW_CLASS=30;
	public const int KW_CONSUMES=31;
	public const int KW_CONTINUE=32;
	public const int KW_DECIMAL=33;
	public const int KW_DEFAULT=34;
	public const int KW_DELEGATE=35;
	public const int KW_DELETE=36;
	public const int KW_DO=37;
	public const int KW_DOUBLE=38;
	public const int KW_ELIF=39;
	public const int KW_ELSE=40;
	public const int KW_ENUM=41;
	public const int KW_EVENT=42;
	public const int KW_EXPLICIT=43;
	public const int KW_EXTERN=44;
	public const int KW_FALSE=45;
	public const int KW_FINALLY=46;
	public const int KW_FLOAT=47;
	public const int KW_FOR=48;
	public const int KW_FOREACH=49;
	public const int KW_IF=50;
	public const int KW_IMPLICIT=51;
	public const int KW_IMPORT=52;
	public const int KW_IN=53;
	public const int KW_INT=54;
	public const int KW_INTERFACE=55;
	public const int KW_INTERNAL=56;
	public const int KW_IS=57;
	public const int KW_LONG=58;
	public const int KW_LOOP=59;
	public const int KW_NAMESPACE=60;
	public const int KW_NEW=61;
	public const int KW_NIL=62;
	public const int KW_OBJECT=63;
	public const int KW_OPERATOR=64;
	public const int KW_OUT=65;
	public const int KW_OVERRIDE=66;
	public const int KW_PARAMS=67;
	public const int KW_PARTIAL=68;
	public const int KW_PRIVATE=69;
	public const int KW_PROTECTED=70;
	public const int KW_PUBLIC=71;
	public const int KW_READONLY=72;
	public const int KW_REF=73;
	public const int KW_RETURN=74;
	public const int KW_SBYTE=75;
	public const int KW_SEALED=76;
	public const int KW_SHORT=77;
	public const int KW_SIZEOF=78;
	public const int KW_STATIC=79;
	public const int KW_STRING=80;
	public const int KW_STRUCT=81;
	public const int KW_SWITCH=82;
	public const int KW_THIS=83;
	public const int KW_THROW=84;
	public const int KW_TRUE=85;
	public const int KW_TRY=86;
	public const int KW_TYPEOF=87;
	public const int KW_UINT=88;
	public const int KW_ULONG=89;
	public const int KW_USHORT=90;
	public const int KW_USING=91;
	public const int KW_VAR=92;
	public const int KW_VIRTUAL=93;
	public const int KW_VOID=94;
	public const int KW_VOLATILE=95;
	public const int KW_WHERE=96;
	public const int KW_WHILE=97;
	public const int LINE_COMMENT=98;
	public const int LITERAL_STRING=99;
	public const int NEW_LINE=100;
	public const int NEW_LINE_CHARACTER=101;
	public const int OP_AMPERSAND=102;
	public const int OP_AMPERSAND_AMPERSAND=103;
	public const int OP_AMPERSAND_EQUALS=104;
	public const int OP_ASTERISK=105;
	public const int OP_ASTERISK_EQUALS=106;
	public const int OP_BAR=107;
	public const int OP_BAR_BAR=108;
	public const int OP_BAR_EQUALS=109;
	public const int OP_BRACE_CLOSE=110;
	public const int OP_BRACE_OPEN=111;
	public const int OP_BRACKET_CLOSE=112;
	public const int OP_BRACKET_OPEN=113;
	public const int OP_CARET=114;
	public const int OP_CARET_EQUALS=115;
	public const int OP_COLON=116;
	public const int OP_COLON_COLON=117;
	public const int OP_COMMA=118;
	public const int OP_DOT=119;
	public const int OP_EQUALS=120;
	public const int OP_EQUALS_EQUALS=121;
	public const int OP_EQUALS_GREATER_THAN=122;
	public const int OP_EXCLAMATION=123;
	public const int OP_EXCLAMATION_EQUALS=124;
	public const int OP_GREATER_THAN=125;
	public const int OP_GREATER_THAN_EQUALS=126;
	public const int OP_GREATER_THAN_GREATER_THAN=127;
	public const int OP_GREATER_THAN_GREATER_THAN_EQUALS=128;
	public const int OP_GREATER_THAN_GREATER_THAN_FIRST=129;
	public const int OP_GREATER_THAN_GREATER_THAN_SECOND=130;
	public const int OP_LESS_THAN=131;
	public const int OP_LESS_THAN_EQUALS=132;
	public const int OP_LESS_THAN_LESS_THAN=133;
	public const int OP_LESS_THAN_LESS_THAN_EQUALS=134;
	public const int OP_MINUS=135;
	public const int OP_MINUS_EQUALS=136;
	public const int OP_MINUS_MINUS=137;
	public const int OP_PAREN_CLOSE=138;
	public const int OP_PAREN_OPEN=139;
	public const int OP_PERCENT=140;
	public const int OP_PERCENT_EQUALS=141;
	public const int OP_PLUS=142;
	public const int OP_PLUS_EQUALS=143;
	public const int OP_PLUS_PLUS=144;
	public const int OP_QUESTION=145;
	public const int OP_QUESTION_QUESTION=146;
	public const int OP_SEMICOLON=147;
	public const int OP_SLASH=148;
	public const int OP_SLASH_EQUALS=149;
	public const int OP_TILDE=150;
	public const int STRING=151;
	public const int VERBATIM_STRING=152;
	public const int WHITESPACE=153;

    // delegates
    // delegators

	public TrussLexer()
	{
		OnCreated();
	}

	public TrussLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public TrussLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Truss.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_KW_ABSTRACT();
	partial void LeaveRule_KW_ABSTRACT();

	// $ANTLR start "KW_ABSTRACT"
	[GrammarRule("KW_ABSTRACT")]
	private void mKW_ABSTRACT()
	{
		EnterRule_KW_ABSTRACT();
		EnterRule("KW_ABSTRACT", 1);
		TraceIn("KW_ABSTRACT", 1);
		try
		{
			int _type = KW_ABSTRACT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2299:13: ( 'abstract' )
			DebugEnterAlt(1);
			// Truss.g:2299:15: 'abstract'
			{
			DebugLocation(2299, 15);
			Match("abstract"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_ABSTRACT", 1);
			LeaveRule("KW_ABSTRACT", 1);
			LeaveRule_KW_ABSTRACT();
		}
	}
	// $ANTLR end "KW_ABSTRACT"

	partial void EnterRule_KW_AS();
	partial void LeaveRule_KW_AS();

	// $ANTLR start "KW_AS"
	[GrammarRule("KW_AS")]
	private void mKW_AS()
	{
		EnterRule_KW_AS();
		EnterRule("KW_AS", 2);
		TraceIn("KW_AS", 2);
		try
		{
			int _type = KW_AS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2300:7: ( 'as' )
			DebugEnterAlt(1);
			// Truss.g:2300:9: 'as'
			{
			DebugLocation(2300, 9);
			Match("as"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_AS", 2);
			LeaveRule("KW_AS", 2);
			LeaveRule_KW_AS();
		}
	}
	// $ANTLR end "KW_AS"

	partial void EnterRule_KW_ASSERT();
	partial void LeaveRule_KW_ASSERT();

	// $ANTLR start "KW_ASSERT"
	[GrammarRule("KW_ASSERT")]
	private void mKW_ASSERT()
	{
		EnterRule_KW_ASSERT();
		EnterRule("KW_ASSERT", 3);
		TraceIn("KW_ASSERT", 3);
		try
		{
			int _type = KW_ASSERT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2301:11: ( 'assert' )
			DebugEnterAlt(1);
			// Truss.g:2301:13: 'assert'
			{
			DebugLocation(2301, 13);
			Match("assert"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_ASSERT", 3);
			LeaveRule("KW_ASSERT", 3);
			LeaveRule_KW_ASSERT();
		}
	}
	// $ANTLR end "KW_ASSERT"

	partial void EnterRule_KW_ASYNC();
	partial void LeaveRule_KW_ASYNC();

	// $ANTLR start "KW_ASYNC"
	[GrammarRule("KW_ASYNC")]
	private void mKW_ASYNC()
	{
		EnterRule_KW_ASYNC();
		EnterRule("KW_ASYNC", 4);
		TraceIn("KW_ASYNC", 4);
		try
		{
			int _type = KW_ASYNC;
			int _channel = DefaultTokenChannel;
			// Truss.g:2302:10: ( 'async' )
			DebugEnterAlt(1);
			// Truss.g:2302:12: 'async'
			{
			DebugLocation(2302, 12);
			Match("async"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_ASYNC", 4);
			LeaveRule("KW_ASYNC", 4);
			LeaveRule_KW_ASYNC();
		}
	}
	// $ANTLR end "KW_ASYNC"

	partial void EnterRule_KW_AWAIT();
	partial void LeaveRule_KW_AWAIT();

	// $ANTLR start "KW_AWAIT"
	[GrammarRule("KW_AWAIT")]
	private void mKW_AWAIT()
	{
		EnterRule_KW_AWAIT();
		EnterRule("KW_AWAIT", 5);
		TraceIn("KW_AWAIT", 5);
		try
		{
			int _type = KW_AWAIT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2303:10: ( 'await' )
			DebugEnterAlt(1);
			// Truss.g:2303:12: 'await'
			{
			DebugLocation(2303, 12);
			Match("await"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_AWAIT", 5);
			LeaveRule("KW_AWAIT", 5);
			LeaveRule_KW_AWAIT();
		}
	}
	// $ANTLR end "KW_AWAIT"

	partial void EnterRule_KW_BASE();
	partial void LeaveRule_KW_BASE();

	// $ANTLR start "KW_BASE"
	[GrammarRule("KW_BASE")]
	private void mKW_BASE()
	{
		EnterRule_KW_BASE();
		EnterRule("KW_BASE", 6);
		TraceIn("KW_BASE", 6);
		try
		{
			int _type = KW_BASE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2304:9: ( 'base' )
			DebugEnterAlt(1);
			// Truss.g:2304:11: 'base'
			{
			DebugLocation(2304, 11);
			Match("base"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_BASE", 6);
			LeaveRule("KW_BASE", 6);
			LeaveRule_KW_BASE();
		}
	}
	// $ANTLR end "KW_BASE"

	partial void EnterRule_KW_BOOL();
	partial void LeaveRule_KW_BOOL();

	// $ANTLR start "KW_BOOL"
	[GrammarRule("KW_BOOL")]
	private void mKW_BOOL()
	{
		EnterRule_KW_BOOL();
		EnterRule("KW_BOOL", 7);
		TraceIn("KW_BOOL", 7);
		try
		{
			int _type = KW_BOOL;
			int _channel = DefaultTokenChannel;
			// Truss.g:2305:9: ( 'bool' )
			DebugEnterAlt(1);
			// Truss.g:2305:11: 'bool'
			{
			DebugLocation(2305, 11);
			Match("bool"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_BOOL", 7);
			LeaveRule("KW_BOOL", 7);
			LeaveRule_KW_BOOL();
		}
	}
	// $ANTLR end "KW_BOOL"

	partial void EnterRule_KW_BREAK();
	partial void LeaveRule_KW_BREAK();

	// $ANTLR start "KW_BREAK"
	[GrammarRule("KW_BREAK")]
	private void mKW_BREAK()
	{
		EnterRule_KW_BREAK();
		EnterRule("KW_BREAK", 8);
		TraceIn("KW_BREAK", 8);
		try
		{
			int _type = KW_BREAK;
			int _channel = DefaultTokenChannel;
			// Truss.g:2306:10: ( 'break' )
			DebugEnterAlt(1);
			// Truss.g:2306:12: 'break'
			{
			DebugLocation(2306, 12);
			Match("break"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_BREAK", 8);
			LeaveRule("KW_BREAK", 8);
			LeaveRule_KW_BREAK();
		}
	}
	// $ANTLR end "KW_BREAK"

	partial void EnterRule_KW_BYTE();
	partial void LeaveRule_KW_BYTE();

	// $ANTLR start "KW_BYTE"
	[GrammarRule("KW_BYTE")]
	private void mKW_BYTE()
	{
		EnterRule_KW_BYTE();
		EnterRule("KW_BYTE", 9);
		TraceIn("KW_BYTE", 9);
		try
		{
			int _type = KW_BYTE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2307:9: ( 'byte' )
			DebugEnterAlt(1);
			// Truss.g:2307:11: 'byte'
			{
			DebugLocation(2307, 11);
			Match("byte"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_BYTE", 9);
			LeaveRule("KW_BYTE", 9);
			LeaveRule_KW_BYTE();
		}
	}
	// $ANTLR end "KW_BYTE"

	partial void EnterRule_KW_CASE();
	partial void LeaveRule_KW_CASE();

	// $ANTLR start "KW_CASE"
	[GrammarRule("KW_CASE")]
	private void mKW_CASE()
	{
		EnterRule_KW_CASE();
		EnterRule("KW_CASE", 10);
		TraceIn("KW_CASE", 10);
		try
		{
			int _type = KW_CASE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2308:9: ( 'case' )
			DebugEnterAlt(1);
			// Truss.g:2308:11: 'case'
			{
			DebugLocation(2308, 11);
			Match("case"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_CASE", 10);
			LeaveRule("KW_CASE", 10);
			LeaveRule_KW_CASE();
		}
	}
	// $ANTLR end "KW_CASE"

	partial void EnterRule_KW_CATCH();
	partial void LeaveRule_KW_CATCH();

	// $ANTLR start "KW_CATCH"
	[GrammarRule("KW_CATCH")]
	private void mKW_CATCH()
	{
		EnterRule_KW_CATCH();
		EnterRule("KW_CATCH", 11);
		TraceIn("KW_CATCH", 11);
		try
		{
			int _type = KW_CATCH;
			int _channel = DefaultTokenChannel;
			// Truss.g:2309:10: ( 'catch' )
			DebugEnterAlt(1);
			// Truss.g:2309:12: 'catch'
			{
			DebugLocation(2309, 12);
			Match("catch"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_CATCH", 11);
			LeaveRule("KW_CATCH", 11);
			LeaveRule_KW_CATCH();
		}
	}
	// $ANTLR end "KW_CATCH"

	partial void EnterRule_KW_CHAR();
	partial void LeaveRule_KW_CHAR();

	// $ANTLR start "KW_CHAR"
	[GrammarRule("KW_CHAR")]
	private void mKW_CHAR()
	{
		EnterRule_KW_CHAR();
		EnterRule("KW_CHAR", 12);
		TraceIn("KW_CHAR", 12);
		try
		{
			int _type = KW_CHAR;
			int _channel = DefaultTokenChannel;
			// Truss.g:2310:9: ( 'char' )
			DebugEnterAlt(1);
			// Truss.g:2310:11: 'char'
			{
			DebugLocation(2310, 11);
			Match("char"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_CHAR", 12);
			LeaveRule("KW_CHAR", 12);
			LeaveRule_KW_CHAR();
		}
	}
	// $ANTLR end "KW_CHAR"

	partial void EnterRule_KW_CLASS();
	partial void LeaveRule_KW_CLASS();

	// $ANTLR start "KW_CLASS"
	[GrammarRule("KW_CLASS")]
	private void mKW_CLASS()
	{
		EnterRule_KW_CLASS();
		EnterRule("KW_CLASS", 13);
		TraceIn("KW_CLASS", 13);
		try
		{
			int _type = KW_CLASS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2311:10: ( 'class' )
			DebugEnterAlt(1);
			// Truss.g:2311:12: 'class'
			{
			DebugLocation(2311, 12);
			Match("class"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_CLASS", 13);
			LeaveRule("KW_CLASS", 13);
			LeaveRule_KW_CLASS();
		}
	}
	// $ANTLR end "KW_CLASS"

	partial void EnterRule_KW_CONSUMES();
	partial void LeaveRule_KW_CONSUMES();

	// $ANTLR start "KW_CONSUMES"
	[GrammarRule("KW_CONSUMES")]
	private void mKW_CONSUMES()
	{
		EnterRule_KW_CONSUMES();
		EnterRule("KW_CONSUMES", 14);
		TraceIn("KW_CONSUMES", 14);
		try
		{
			int _type = KW_CONSUMES;
			int _channel = DefaultTokenChannel;
			// Truss.g:2312:13: ( 'consumes' )
			DebugEnterAlt(1);
			// Truss.g:2312:15: 'consumes'
			{
			DebugLocation(2312, 15);
			Match("consumes"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_CONSUMES", 14);
			LeaveRule("KW_CONSUMES", 14);
			LeaveRule_KW_CONSUMES();
		}
	}
	// $ANTLR end "KW_CONSUMES"

	partial void EnterRule_KW_CONTINUE();
	partial void LeaveRule_KW_CONTINUE();

	// $ANTLR start "KW_CONTINUE"
	[GrammarRule("KW_CONTINUE")]
	private void mKW_CONTINUE()
	{
		EnterRule_KW_CONTINUE();
		EnterRule("KW_CONTINUE", 15);
		TraceIn("KW_CONTINUE", 15);
		try
		{
			int _type = KW_CONTINUE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2313:13: ( 'continue' )
			DebugEnterAlt(1);
			// Truss.g:2313:15: 'continue'
			{
			DebugLocation(2313, 15);
			Match("continue"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_CONTINUE", 15);
			LeaveRule("KW_CONTINUE", 15);
			LeaveRule_KW_CONTINUE();
		}
	}
	// $ANTLR end "KW_CONTINUE"

	partial void EnterRule_KW_DECIMAL();
	partial void LeaveRule_KW_DECIMAL();

	// $ANTLR start "KW_DECIMAL"
	[GrammarRule("KW_DECIMAL")]
	private void mKW_DECIMAL()
	{
		EnterRule_KW_DECIMAL();
		EnterRule("KW_DECIMAL", 16);
		TraceIn("KW_DECIMAL", 16);
		try
		{
			int _type = KW_DECIMAL;
			int _channel = DefaultTokenChannel;
			// Truss.g:2314:12: ( 'decimal' )
			DebugEnterAlt(1);
			// Truss.g:2314:14: 'decimal'
			{
			DebugLocation(2314, 14);
			Match("decimal"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_DECIMAL", 16);
			LeaveRule("KW_DECIMAL", 16);
			LeaveRule_KW_DECIMAL();
		}
	}
	// $ANTLR end "KW_DECIMAL"

	partial void EnterRule_KW_DEFAULT();
	partial void LeaveRule_KW_DEFAULT();

	// $ANTLR start "KW_DEFAULT"
	[GrammarRule("KW_DEFAULT")]
	private void mKW_DEFAULT()
	{
		EnterRule_KW_DEFAULT();
		EnterRule("KW_DEFAULT", 17);
		TraceIn("KW_DEFAULT", 17);
		try
		{
			int _type = KW_DEFAULT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2315:12: ( 'default' )
			DebugEnterAlt(1);
			// Truss.g:2315:14: 'default'
			{
			DebugLocation(2315, 14);
			Match("default"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_DEFAULT", 17);
			LeaveRule("KW_DEFAULT", 17);
			LeaveRule_KW_DEFAULT();
		}
	}
	// $ANTLR end "KW_DEFAULT"

	partial void EnterRule_KW_DELEGATE();
	partial void LeaveRule_KW_DELEGATE();

	// $ANTLR start "KW_DELEGATE"
	[GrammarRule("KW_DELEGATE")]
	private void mKW_DELEGATE()
	{
		EnterRule_KW_DELEGATE();
		EnterRule("KW_DELEGATE", 18);
		TraceIn("KW_DELEGATE", 18);
		try
		{
			int _type = KW_DELEGATE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2316:13: ( 'delegate' )
			DebugEnterAlt(1);
			// Truss.g:2316:15: 'delegate'
			{
			DebugLocation(2316, 15);
			Match("delegate"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_DELEGATE", 18);
			LeaveRule("KW_DELEGATE", 18);
			LeaveRule_KW_DELEGATE();
		}
	}
	// $ANTLR end "KW_DELEGATE"

	partial void EnterRule_KW_DELETE();
	partial void LeaveRule_KW_DELETE();

	// $ANTLR start "KW_DELETE"
	[GrammarRule("KW_DELETE")]
	private void mKW_DELETE()
	{
		EnterRule_KW_DELETE();
		EnterRule("KW_DELETE", 19);
		TraceIn("KW_DELETE", 19);
		try
		{
			int _type = KW_DELETE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2317:11: ( 'delete' )
			DebugEnterAlt(1);
			// Truss.g:2317:13: 'delete'
			{
			DebugLocation(2317, 13);
			Match("delete"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_DELETE", 19);
			LeaveRule("KW_DELETE", 19);
			LeaveRule_KW_DELETE();
		}
	}
	// $ANTLR end "KW_DELETE"

	partial void EnterRule_KW_DO();
	partial void LeaveRule_KW_DO();

	// $ANTLR start "KW_DO"
	[GrammarRule("KW_DO")]
	private void mKW_DO()
	{
		EnterRule_KW_DO();
		EnterRule("KW_DO", 20);
		TraceIn("KW_DO", 20);
		try
		{
			int _type = KW_DO;
			int _channel = DefaultTokenChannel;
			// Truss.g:2318:7: ( 'do' )
			DebugEnterAlt(1);
			// Truss.g:2318:9: 'do'
			{
			DebugLocation(2318, 9);
			Match("do"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_DO", 20);
			LeaveRule("KW_DO", 20);
			LeaveRule_KW_DO();
		}
	}
	// $ANTLR end "KW_DO"

	partial void EnterRule_KW_DOUBLE();
	partial void LeaveRule_KW_DOUBLE();

	// $ANTLR start "KW_DOUBLE"
	[GrammarRule("KW_DOUBLE")]
	private void mKW_DOUBLE()
	{
		EnterRule_KW_DOUBLE();
		EnterRule("KW_DOUBLE", 21);
		TraceIn("KW_DOUBLE", 21);
		try
		{
			int _type = KW_DOUBLE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2319:11: ( 'double' )
			DebugEnterAlt(1);
			// Truss.g:2319:13: 'double'
			{
			DebugLocation(2319, 13);
			Match("double"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_DOUBLE", 21);
			LeaveRule("KW_DOUBLE", 21);
			LeaveRule_KW_DOUBLE();
		}
	}
	// $ANTLR end "KW_DOUBLE"

	partial void EnterRule_KW_ELIF();
	partial void LeaveRule_KW_ELIF();

	// $ANTLR start "KW_ELIF"
	[GrammarRule("KW_ELIF")]
	private void mKW_ELIF()
	{
		EnterRule_KW_ELIF();
		EnterRule("KW_ELIF", 22);
		TraceIn("KW_ELIF", 22);
		try
		{
			int _type = KW_ELIF;
			int _channel = DefaultTokenChannel;
			// Truss.g:2320:9: ( 'elif' )
			DebugEnterAlt(1);
			// Truss.g:2320:11: 'elif'
			{
			DebugLocation(2320, 11);
			Match("elif"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_ELIF", 22);
			LeaveRule("KW_ELIF", 22);
			LeaveRule_KW_ELIF();
		}
	}
	// $ANTLR end "KW_ELIF"

	partial void EnterRule_KW_ELSE();
	partial void LeaveRule_KW_ELSE();

	// $ANTLR start "KW_ELSE"
	[GrammarRule("KW_ELSE")]
	private void mKW_ELSE()
	{
		EnterRule_KW_ELSE();
		EnterRule("KW_ELSE", 23);
		TraceIn("KW_ELSE", 23);
		try
		{
			int _type = KW_ELSE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2321:9: ( 'else' )
			DebugEnterAlt(1);
			// Truss.g:2321:11: 'else'
			{
			DebugLocation(2321, 11);
			Match("else"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_ELSE", 23);
			LeaveRule("KW_ELSE", 23);
			LeaveRule_KW_ELSE();
		}
	}
	// $ANTLR end "KW_ELSE"

	partial void EnterRule_KW_ENUM();
	partial void LeaveRule_KW_ENUM();

	// $ANTLR start "KW_ENUM"
	[GrammarRule("KW_ENUM")]
	private void mKW_ENUM()
	{
		EnterRule_KW_ENUM();
		EnterRule("KW_ENUM", 24);
		TraceIn("KW_ENUM", 24);
		try
		{
			int _type = KW_ENUM;
			int _channel = DefaultTokenChannel;
			// Truss.g:2322:9: ( 'enum' )
			DebugEnterAlt(1);
			// Truss.g:2322:11: 'enum'
			{
			DebugLocation(2322, 11);
			Match("enum"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_ENUM", 24);
			LeaveRule("KW_ENUM", 24);
			LeaveRule_KW_ENUM();
		}
	}
	// $ANTLR end "KW_ENUM"

	partial void EnterRule_KW_EVENT();
	partial void LeaveRule_KW_EVENT();

	// $ANTLR start "KW_EVENT"
	[GrammarRule("KW_EVENT")]
	private void mKW_EVENT()
	{
		EnterRule_KW_EVENT();
		EnterRule("KW_EVENT", 25);
		TraceIn("KW_EVENT", 25);
		try
		{
			int _type = KW_EVENT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2323:10: ( 'event' )
			DebugEnterAlt(1);
			// Truss.g:2323:12: 'event'
			{
			DebugLocation(2323, 12);
			Match("event"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_EVENT", 25);
			LeaveRule("KW_EVENT", 25);
			LeaveRule_KW_EVENT();
		}
	}
	// $ANTLR end "KW_EVENT"

	partial void EnterRule_KW_EXPLICIT();
	partial void LeaveRule_KW_EXPLICIT();

	// $ANTLR start "KW_EXPLICIT"
	[GrammarRule("KW_EXPLICIT")]
	private void mKW_EXPLICIT()
	{
		EnterRule_KW_EXPLICIT();
		EnterRule("KW_EXPLICIT", 26);
		TraceIn("KW_EXPLICIT", 26);
		try
		{
			int _type = KW_EXPLICIT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2324:13: ( 'explicit' )
			DebugEnterAlt(1);
			// Truss.g:2324:15: 'explicit'
			{
			DebugLocation(2324, 15);
			Match("explicit"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_EXPLICIT", 26);
			LeaveRule("KW_EXPLICIT", 26);
			LeaveRule_KW_EXPLICIT();
		}
	}
	// $ANTLR end "KW_EXPLICIT"

	partial void EnterRule_KW_EXTERN();
	partial void LeaveRule_KW_EXTERN();

	// $ANTLR start "KW_EXTERN"
	[GrammarRule("KW_EXTERN")]
	private void mKW_EXTERN()
	{
		EnterRule_KW_EXTERN();
		EnterRule("KW_EXTERN", 27);
		TraceIn("KW_EXTERN", 27);
		try
		{
			int _type = KW_EXTERN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2325:11: ( 'extern' )
			DebugEnterAlt(1);
			// Truss.g:2325:13: 'extern'
			{
			DebugLocation(2325, 13);
			Match("extern"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_EXTERN", 27);
			LeaveRule("KW_EXTERN", 27);
			LeaveRule_KW_EXTERN();
		}
	}
	// $ANTLR end "KW_EXTERN"

	partial void EnterRule_KW_FALSE();
	partial void LeaveRule_KW_FALSE();

	// $ANTLR start "KW_FALSE"
	[GrammarRule("KW_FALSE")]
	private void mKW_FALSE()
	{
		EnterRule_KW_FALSE();
		EnterRule("KW_FALSE", 28);
		TraceIn("KW_FALSE", 28);
		try
		{
			int _type = KW_FALSE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2326:10: ( 'false' )
			DebugEnterAlt(1);
			// Truss.g:2326:12: 'false'
			{
			DebugLocation(2326, 12);
			Match("false"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_FALSE", 28);
			LeaveRule("KW_FALSE", 28);
			LeaveRule_KW_FALSE();
		}
	}
	// $ANTLR end "KW_FALSE"

	partial void EnterRule_KW_FINALLY();
	partial void LeaveRule_KW_FINALLY();

	// $ANTLR start "KW_FINALLY"
	[GrammarRule("KW_FINALLY")]
	private void mKW_FINALLY()
	{
		EnterRule_KW_FINALLY();
		EnterRule("KW_FINALLY", 29);
		TraceIn("KW_FINALLY", 29);
		try
		{
			int _type = KW_FINALLY;
			int _channel = DefaultTokenChannel;
			// Truss.g:2327:12: ( 'finally' )
			DebugEnterAlt(1);
			// Truss.g:2327:14: 'finally'
			{
			DebugLocation(2327, 14);
			Match("finally"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_FINALLY", 29);
			LeaveRule("KW_FINALLY", 29);
			LeaveRule_KW_FINALLY();
		}
	}
	// $ANTLR end "KW_FINALLY"

	partial void EnterRule_KW_FLOAT();
	partial void LeaveRule_KW_FLOAT();

	// $ANTLR start "KW_FLOAT"
	[GrammarRule("KW_FLOAT")]
	private void mKW_FLOAT()
	{
		EnterRule_KW_FLOAT();
		EnterRule("KW_FLOAT", 30);
		TraceIn("KW_FLOAT", 30);
		try
		{
			int _type = KW_FLOAT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2328:10: ( 'float' )
			DebugEnterAlt(1);
			// Truss.g:2328:12: 'float'
			{
			DebugLocation(2328, 12);
			Match("float"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_FLOAT", 30);
			LeaveRule("KW_FLOAT", 30);
			LeaveRule_KW_FLOAT();
		}
	}
	// $ANTLR end "KW_FLOAT"

	partial void EnterRule_KW_FOR();
	partial void LeaveRule_KW_FOR();

	// $ANTLR start "KW_FOR"
	[GrammarRule("KW_FOR")]
	private void mKW_FOR()
	{
		EnterRule_KW_FOR();
		EnterRule("KW_FOR", 31);
		TraceIn("KW_FOR", 31);
		try
		{
			int _type = KW_FOR;
			int _channel = DefaultTokenChannel;
			// Truss.g:2329:8: ( 'for' )
			DebugEnterAlt(1);
			// Truss.g:2329:10: 'for'
			{
			DebugLocation(2329, 10);
			Match("for"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_FOR", 31);
			LeaveRule("KW_FOR", 31);
			LeaveRule_KW_FOR();
		}
	}
	// $ANTLR end "KW_FOR"

	partial void EnterRule_KW_FOREACH();
	partial void LeaveRule_KW_FOREACH();

	// $ANTLR start "KW_FOREACH"
	[GrammarRule("KW_FOREACH")]
	private void mKW_FOREACH()
	{
		EnterRule_KW_FOREACH();
		EnterRule("KW_FOREACH", 32);
		TraceIn("KW_FOREACH", 32);
		try
		{
			int _type = KW_FOREACH;
			int _channel = DefaultTokenChannel;
			// Truss.g:2330:12: ( 'foreach' )
			DebugEnterAlt(1);
			// Truss.g:2330:14: 'foreach'
			{
			DebugLocation(2330, 14);
			Match("foreach"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_FOREACH", 32);
			LeaveRule("KW_FOREACH", 32);
			LeaveRule_KW_FOREACH();
		}
	}
	// $ANTLR end "KW_FOREACH"

	partial void EnterRule_KW_IF();
	partial void LeaveRule_KW_IF();

	// $ANTLR start "KW_IF"
	[GrammarRule("KW_IF")]
	private void mKW_IF()
	{
		EnterRule_KW_IF();
		EnterRule("KW_IF", 33);
		TraceIn("KW_IF", 33);
		try
		{
			int _type = KW_IF;
			int _channel = DefaultTokenChannel;
			// Truss.g:2331:7: ( 'if' )
			DebugEnterAlt(1);
			// Truss.g:2331:9: 'if'
			{
			DebugLocation(2331, 9);
			Match("if"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_IF", 33);
			LeaveRule("KW_IF", 33);
			LeaveRule_KW_IF();
		}
	}
	// $ANTLR end "KW_IF"

	partial void EnterRule_KW_IMPLICIT();
	partial void LeaveRule_KW_IMPLICIT();

	// $ANTLR start "KW_IMPLICIT"
	[GrammarRule("KW_IMPLICIT")]
	private void mKW_IMPLICIT()
	{
		EnterRule_KW_IMPLICIT();
		EnterRule("KW_IMPLICIT", 34);
		TraceIn("KW_IMPLICIT", 34);
		try
		{
			int _type = KW_IMPLICIT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2332:13: ( 'implicit' )
			DebugEnterAlt(1);
			// Truss.g:2332:15: 'implicit'
			{
			DebugLocation(2332, 15);
			Match("implicit"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_IMPLICIT", 34);
			LeaveRule("KW_IMPLICIT", 34);
			LeaveRule_KW_IMPLICIT();
		}
	}
	// $ANTLR end "KW_IMPLICIT"

	partial void EnterRule_KW_IMPORT();
	partial void LeaveRule_KW_IMPORT();

	// $ANTLR start "KW_IMPORT"
	[GrammarRule("KW_IMPORT")]
	private void mKW_IMPORT()
	{
		EnterRule_KW_IMPORT();
		EnterRule("KW_IMPORT", 35);
		TraceIn("KW_IMPORT", 35);
		try
		{
			int _type = KW_IMPORT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2333:11: ( 'import' )
			DebugEnterAlt(1);
			// Truss.g:2333:13: 'import'
			{
			DebugLocation(2333, 13);
			Match("import"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_IMPORT", 35);
			LeaveRule("KW_IMPORT", 35);
			LeaveRule_KW_IMPORT();
		}
	}
	// $ANTLR end "KW_IMPORT"

	partial void EnterRule_KW_IN();
	partial void LeaveRule_KW_IN();

	// $ANTLR start "KW_IN"
	[GrammarRule("KW_IN")]
	private void mKW_IN()
	{
		EnterRule_KW_IN();
		EnterRule("KW_IN", 36);
		TraceIn("KW_IN", 36);
		try
		{
			int _type = KW_IN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2334:7: ( 'in' )
			DebugEnterAlt(1);
			// Truss.g:2334:9: 'in'
			{
			DebugLocation(2334, 9);
			Match("in"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_IN", 36);
			LeaveRule("KW_IN", 36);
			LeaveRule_KW_IN();
		}
	}
	// $ANTLR end "KW_IN"

	partial void EnterRule_KW_INT();
	partial void LeaveRule_KW_INT();

	// $ANTLR start "KW_INT"
	[GrammarRule("KW_INT")]
	private void mKW_INT()
	{
		EnterRule_KW_INT();
		EnterRule("KW_INT", 37);
		TraceIn("KW_INT", 37);
		try
		{
			int _type = KW_INT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2335:8: ( 'int' )
			DebugEnterAlt(1);
			// Truss.g:2335:10: 'int'
			{
			DebugLocation(2335, 10);
			Match("int"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_INT", 37);
			LeaveRule("KW_INT", 37);
			LeaveRule_KW_INT();
		}
	}
	// $ANTLR end "KW_INT"

	partial void EnterRule_KW_INTERFACE();
	partial void LeaveRule_KW_INTERFACE();

	// $ANTLR start "KW_INTERFACE"
	[GrammarRule("KW_INTERFACE")]
	private void mKW_INTERFACE()
	{
		EnterRule_KW_INTERFACE();
		EnterRule("KW_INTERFACE", 38);
		TraceIn("KW_INTERFACE", 38);
		try
		{
			int _type = KW_INTERFACE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2336:14: ( 'interface' )
			DebugEnterAlt(1);
			// Truss.g:2336:16: 'interface'
			{
			DebugLocation(2336, 16);
			Match("interface"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_INTERFACE", 38);
			LeaveRule("KW_INTERFACE", 38);
			LeaveRule_KW_INTERFACE();
		}
	}
	// $ANTLR end "KW_INTERFACE"

	partial void EnterRule_KW_INTERNAL();
	partial void LeaveRule_KW_INTERNAL();

	// $ANTLR start "KW_INTERNAL"
	[GrammarRule("KW_INTERNAL")]
	private void mKW_INTERNAL()
	{
		EnterRule_KW_INTERNAL();
		EnterRule("KW_INTERNAL", 39);
		TraceIn("KW_INTERNAL", 39);
		try
		{
			int _type = KW_INTERNAL;
			int _channel = DefaultTokenChannel;
			// Truss.g:2337:13: ( 'internal' )
			DebugEnterAlt(1);
			// Truss.g:2337:15: 'internal'
			{
			DebugLocation(2337, 15);
			Match("internal"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_INTERNAL", 39);
			LeaveRule("KW_INTERNAL", 39);
			LeaveRule_KW_INTERNAL();
		}
	}
	// $ANTLR end "KW_INTERNAL"

	partial void EnterRule_KW_IS();
	partial void LeaveRule_KW_IS();

	// $ANTLR start "KW_IS"
	[GrammarRule("KW_IS")]
	private void mKW_IS()
	{
		EnterRule_KW_IS();
		EnterRule("KW_IS", 40);
		TraceIn("KW_IS", 40);
		try
		{
			int _type = KW_IS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2338:7: ( 'is' )
			DebugEnterAlt(1);
			// Truss.g:2338:9: 'is'
			{
			DebugLocation(2338, 9);
			Match("is"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_IS", 40);
			LeaveRule("KW_IS", 40);
			LeaveRule_KW_IS();
		}
	}
	// $ANTLR end "KW_IS"

	partial void EnterRule_KW_LONG();
	partial void LeaveRule_KW_LONG();

	// $ANTLR start "KW_LONG"
	[GrammarRule("KW_LONG")]
	private void mKW_LONG()
	{
		EnterRule_KW_LONG();
		EnterRule("KW_LONG", 41);
		TraceIn("KW_LONG", 41);
		try
		{
			int _type = KW_LONG;
			int _channel = DefaultTokenChannel;
			// Truss.g:2339:9: ( 'long' )
			DebugEnterAlt(1);
			// Truss.g:2339:11: 'long'
			{
			DebugLocation(2339, 11);
			Match("long"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_LONG", 41);
			LeaveRule("KW_LONG", 41);
			LeaveRule_KW_LONG();
		}
	}
	// $ANTLR end "KW_LONG"

	partial void EnterRule_KW_LOOP();
	partial void LeaveRule_KW_LOOP();

	// $ANTLR start "KW_LOOP"
	[GrammarRule("KW_LOOP")]
	private void mKW_LOOP()
	{
		EnterRule_KW_LOOP();
		EnterRule("KW_LOOP", 42);
		TraceIn("KW_LOOP", 42);
		try
		{
			int _type = KW_LOOP;
			int _channel = DefaultTokenChannel;
			// Truss.g:2340:9: ( 'loop' )
			DebugEnterAlt(1);
			// Truss.g:2340:11: 'loop'
			{
			DebugLocation(2340, 11);
			Match("loop"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_LOOP", 42);
			LeaveRule("KW_LOOP", 42);
			LeaveRule_KW_LOOP();
		}
	}
	// $ANTLR end "KW_LOOP"

	partial void EnterRule_KW_NAMESPACE();
	partial void LeaveRule_KW_NAMESPACE();

	// $ANTLR start "KW_NAMESPACE"
	[GrammarRule("KW_NAMESPACE")]
	private void mKW_NAMESPACE()
	{
		EnterRule_KW_NAMESPACE();
		EnterRule("KW_NAMESPACE", 43);
		TraceIn("KW_NAMESPACE", 43);
		try
		{
			int _type = KW_NAMESPACE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2341:14: ( 'namespace' )
			DebugEnterAlt(1);
			// Truss.g:2341:16: 'namespace'
			{
			DebugLocation(2341, 16);
			Match("namespace"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_NAMESPACE", 43);
			LeaveRule("KW_NAMESPACE", 43);
			LeaveRule_KW_NAMESPACE();
		}
	}
	// $ANTLR end "KW_NAMESPACE"

	partial void EnterRule_KW_NEW();
	partial void LeaveRule_KW_NEW();

	// $ANTLR start "KW_NEW"
	[GrammarRule("KW_NEW")]
	private void mKW_NEW()
	{
		EnterRule_KW_NEW();
		EnterRule("KW_NEW", 44);
		TraceIn("KW_NEW", 44);
		try
		{
			int _type = KW_NEW;
			int _channel = DefaultTokenChannel;
			// Truss.g:2342:8: ( 'new' )
			DebugEnterAlt(1);
			// Truss.g:2342:10: 'new'
			{
			DebugLocation(2342, 10);
			Match("new"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_NEW", 44);
			LeaveRule("KW_NEW", 44);
			LeaveRule_KW_NEW();
		}
	}
	// $ANTLR end "KW_NEW"

	partial void EnterRule_KW_NIL();
	partial void LeaveRule_KW_NIL();

	// $ANTLR start "KW_NIL"
	[GrammarRule("KW_NIL")]
	private void mKW_NIL()
	{
		EnterRule_KW_NIL();
		EnterRule("KW_NIL", 45);
		TraceIn("KW_NIL", 45);
		try
		{
			int _type = KW_NIL;
			int _channel = DefaultTokenChannel;
			// Truss.g:2343:8: ( 'nil' )
			DebugEnterAlt(1);
			// Truss.g:2343:10: 'nil'
			{
			DebugLocation(2343, 10);
			Match("nil"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_NIL", 45);
			LeaveRule("KW_NIL", 45);
			LeaveRule_KW_NIL();
		}
	}
	// $ANTLR end "KW_NIL"

	partial void EnterRule_KW_OBJECT();
	partial void LeaveRule_KW_OBJECT();

	// $ANTLR start "KW_OBJECT"
	[GrammarRule("KW_OBJECT")]
	private void mKW_OBJECT()
	{
		EnterRule_KW_OBJECT();
		EnterRule("KW_OBJECT", 46);
		TraceIn("KW_OBJECT", 46);
		try
		{
			int _type = KW_OBJECT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2344:11: ( 'object' )
			DebugEnterAlt(1);
			// Truss.g:2344:13: 'object'
			{
			DebugLocation(2344, 13);
			Match("object"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_OBJECT", 46);
			LeaveRule("KW_OBJECT", 46);
			LeaveRule_KW_OBJECT();
		}
	}
	// $ANTLR end "KW_OBJECT"

	partial void EnterRule_KW_OPERATOR();
	partial void LeaveRule_KW_OPERATOR();

	// $ANTLR start "KW_OPERATOR"
	[GrammarRule("KW_OPERATOR")]
	private void mKW_OPERATOR()
	{
		EnterRule_KW_OPERATOR();
		EnterRule("KW_OPERATOR", 47);
		TraceIn("KW_OPERATOR", 47);
		try
		{
			int _type = KW_OPERATOR;
			int _channel = DefaultTokenChannel;
			// Truss.g:2345:13: ( 'operator' )
			DebugEnterAlt(1);
			// Truss.g:2345:15: 'operator'
			{
			DebugLocation(2345, 15);
			Match("operator"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_OPERATOR", 47);
			LeaveRule("KW_OPERATOR", 47);
			LeaveRule_KW_OPERATOR();
		}
	}
	// $ANTLR end "KW_OPERATOR"

	partial void EnterRule_KW_OUT();
	partial void LeaveRule_KW_OUT();

	// $ANTLR start "KW_OUT"
	[GrammarRule("KW_OUT")]
	private void mKW_OUT()
	{
		EnterRule_KW_OUT();
		EnterRule("KW_OUT", 48);
		TraceIn("KW_OUT", 48);
		try
		{
			int _type = KW_OUT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2346:8: ( 'out' )
			DebugEnterAlt(1);
			// Truss.g:2346:10: 'out'
			{
			DebugLocation(2346, 10);
			Match("out"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_OUT", 48);
			LeaveRule("KW_OUT", 48);
			LeaveRule_KW_OUT();
		}
	}
	// $ANTLR end "KW_OUT"

	partial void EnterRule_KW_OVERRIDE();
	partial void LeaveRule_KW_OVERRIDE();

	// $ANTLR start "KW_OVERRIDE"
	[GrammarRule("KW_OVERRIDE")]
	private void mKW_OVERRIDE()
	{
		EnterRule_KW_OVERRIDE();
		EnterRule("KW_OVERRIDE", 49);
		TraceIn("KW_OVERRIDE", 49);
		try
		{
			int _type = KW_OVERRIDE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2347:13: ( 'override' )
			DebugEnterAlt(1);
			// Truss.g:2347:15: 'override'
			{
			DebugLocation(2347, 15);
			Match("override"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_OVERRIDE", 49);
			LeaveRule("KW_OVERRIDE", 49);
			LeaveRule_KW_OVERRIDE();
		}
	}
	// $ANTLR end "KW_OVERRIDE"

	partial void EnterRule_KW_PARAMS();
	partial void LeaveRule_KW_PARAMS();

	// $ANTLR start "KW_PARAMS"
	[GrammarRule("KW_PARAMS")]
	private void mKW_PARAMS()
	{
		EnterRule_KW_PARAMS();
		EnterRule("KW_PARAMS", 50);
		TraceIn("KW_PARAMS", 50);
		try
		{
			int _type = KW_PARAMS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2348:11: ( 'params' )
			DebugEnterAlt(1);
			// Truss.g:2348:13: 'params'
			{
			DebugLocation(2348, 13);
			Match("params"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_PARAMS", 50);
			LeaveRule("KW_PARAMS", 50);
			LeaveRule_KW_PARAMS();
		}
	}
	// $ANTLR end "KW_PARAMS"

	partial void EnterRule_KW_PARTIAL();
	partial void LeaveRule_KW_PARTIAL();

	// $ANTLR start "KW_PARTIAL"
	[GrammarRule("KW_PARTIAL")]
	private void mKW_PARTIAL()
	{
		EnterRule_KW_PARTIAL();
		EnterRule("KW_PARTIAL", 51);
		TraceIn("KW_PARTIAL", 51);
		try
		{
			int _type = KW_PARTIAL;
			int _channel = DefaultTokenChannel;
			// Truss.g:2349:12: ( 'partial' )
			DebugEnterAlt(1);
			// Truss.g:2349:14: 'partial'
			{
			DebugLocation(2349, 14);
			Match("partial"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_PARTIAL", 51);
			LeaveRule("KW_PARTIAL", 51);
			LeaveRule_KW_PARTIAL();
		}
	}
	// $ANTLR end "KW_PARTIAL"

	partial void EnterRule_KW_PRIVATE();
	partial void LeaveRule_KW_PRIVATE();

	// $ANTLR start "KW_PRIVATE"
	[GrammarRule("KW_PRIVATE")]
	private void mKW_PRIVATE()
	{
		EnterRule_KW_PRIVATE();
		EnterRule("KW_PRIVATE", 52);
		TraceIn("KW_PRIVATE", 52);
		try
		{
			int _type = KW_PRIVATE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2350:12: ( 'private' )
			DebugEnterAlt(1);
			// Truss.g:2350:14: 'private'
			{
			DebugLocation(2350, 14);
			Match("private"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_PRIVATE", 52);
			LeaveRule("KW_PRIVATE", 52);
			LeaveRule_KW_PRIVATE();
		}
	}
	// $ANTLR end "KW_PRIVATE"

	partial void EnterRule_KW_PROTECTED();
	partial void LeaveRule_KW_PROTECTED();

	// $ANTLR start "KW_PROTECTED"
	[GrammarRule("KW_PROTECTED")]
	private void mKW_PROTECTED()
	{
		EnterRule_KW_PROTECTED();
		EnterRule("KW_PROTECTED", 53);
		TraceIn("KW_PROTECTED", 53);
		try
		{
			int _type = KW_PROTECTED;
			int _channel = DefaultTokenChannel;
			// Truss.g:2351:14: ( 'protected' )
			DebugEnterAlt(1);
			// Truss.g:2351:16: 'protected'
			{
			DebugLocation(2351, 16);
			Match("protected"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_PROTECTED", 53);
			LeaveRule("KW_PROTECTED", 53);
			LeaveRule_KW_PROTECTED();
		}
	}
	// $ANTLR end "KW_PROTECTED"

	partial void EnterRule_KW_PUBLIC();
	partial void LeaveRule_KW_PUBLIC();

	// $ANTLR start "KW_PUBLIC"
	[GrammarRule("KW_PUBLIC")]
	private void mKW_PUBLIC()
	{
		EnterRule_KW_PUBLIC();
		EnterRule("KW_PUBLIC", 54);
		TraceIn("KW_PUBLIC", 54);
		try
		{
			int _type = KW_PUBLIC;
			int _channel = DefaultTokenChannel;
			// Truss.g:2352:11: ( 'public' )
			DebugEnterAlt(1);
			// Truss.g:2352:13: 'public'
			{
			DebugLocation(2352, 13);
			Match("public"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_PUBLIC", 54);
			LeaveRule("KW_PUBLIC", 54);
			LeaveRule_KW_PUBLIC();
		}
	}
	// $ANTLR end "KW_PUBLIC"

	partial void EnterRule_KW_READONLY();
	partial void LeaveRule_KW_READONLY();

	// $ANTLR start "KW_READONLY"
	[GrammarRule("KW_READONLY")]
	private void mKW_READONLY()
	{
		EnterRule_KW_READONLY();
		EnterRule("KW_READONLY", 55);
		TraceIn("KW_READONLY", 55);
		try
		{
			int _type = KW_READONLY;
			int _channel = DefaultTokenChannel;
			// Truss.g:2353:13: ( 'readonly' )
			DebugEnterAlt(1);
			// Truss.g:2353:15: 'readonly'
			{
			DebugLocation(2353, 15);
			Match("readonly"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_READONLY", 55);
			LeaveRule("KW_READONLY", 55);
			LeaveRule_KW_READONLY();
		}
	}
	// $ANTLR end "KW_READONLY"

	partial void EnterRule_KW_REF();
	partial void LeaveRule_KW_REF();

	// $ANTLR start "KW_REF"
	[GrammarRule("KW_REF")]
	private void mKW_REF()
	{
		EnterRule_KW_REF();
		EnterRule("KW_REF", 56);
		TraceIn("KW_REF", 56);
		try
		{
			int _type = KW_REF;
			int _channel = DefaultTokenChannel;
			// Truss.g:2354:8: ( 'ref' )
			DebugEnterAlt(1);
			// Truss.g:2354:10: 'ref'
			{
			DebugLocation(2354, 10);
			Match("ref"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_REF", 56);
			LeaveRule("KW_REF", 56);
			LeaveRule_KW_REF();
		}
	}
	// $ANTLR end "KW_REF"

	partial void EnterRule_KW_RETURN();
	partial void LeaveRule_KW_RETURN();

	// $ANTLR start "KW_RETURN"
	[GrammarRule("KW_RETURN")]
	private void mKW_RETURN()
	{
		EnterRule_KW_RETURN();
		EnterRule("KW_RETURN", 57);
		TraceIn("KW_RETURN", 57);
		try
		{
			int _type = KW_RETURN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2355:11: ( 'return' )
			DebugEnterAlt(1);
			// Truss.g:2355:13: 'return'
			{
			DebugLocation(2355, 13);
			Match("return"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_RETURN", 57);
			LeaveRule("KW_RETURN", 57);
			LeaveRule_KW_RETURN();
		}
	}
	// $ANTLR end "KW_RETURN"

	partial void EnterRule_KW_SBYTE();
	partial void LeaveRule_KW_SBYTE();

	// $ANTLR start "KW_SBYTE"
	[GrammarRule("KW_SBYTE")]
	private void mKW_SBYTE()
	{
		EnterRule_KW_SBYTE();
		EnterRule("KW_SBYTE", 58);
		TraceIn("KW_SBYTE", 58);
		try
		{
			int _type = KW_SBYTE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2356:10: ( 'sbyte' )
			DebugEnterAlt(1);
			// Truss.g:2356:12: 'sbyte'
			{
			DebugLocation(2356, 12);
			Match("sbyte"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_SBYTE", 58);
			LeaveRule("KW_SBYTE", 58);
			LeaveRule_KW_SBYTE();
		}
	}
	// $ANTLR end "KW_SBYTE"

	partial void EnterRule_KW_SEALED();
	partial void LeaveRule_KW_SEALED();

	// $ANTLR start "KW_SEALED"
	[GrammarRule("KW_SEALED")]
	private void mKW_SEALED()
	{
		EnterRule_KW_SEALED();
		EnterRule("KW_SEALED", 59);
		TraceIn("KW_SEALED", 59);
		try
		{
			int _type = KW_SEALED;
			int _channel = DefaultTokenChannel;
			// Truss.g:2357:11: ( 'sealed' )
			DebugEnterAlt(1);
			// Truss.g:2357:13: 'sealed'
			{
			DebugLocation(2357, 13);
			Match("sealed"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_SEALED", 59);
			LeaveRule("KW_SEALED", 59);
			LeaveRule_KW_SEALED();
		}
	}
	// $ANTLR end "KW_SEALED"

	partial void EnterRule_KW_SHORT();
	partial void LeaveRule_KW_SHORT();

	// $ANTLR start "KW_SHORT"
	[GrammarRule("KW_SHORT")]
	private void mKW_SHORT()
	{
		EnterRule_KW_SHORT();
		EnterRule("KW_SHORT", 60);
		TraceIn("KW_SHORT", 60);
		try
		{
			int _type = KW_SHORT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2358:10: ( 'short' )
			DebugEnterAlt(1);
			// Truss.g:2358:12: 'short'
			{
			DebugLocation(2358, 12);
			Match("short"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_SHORT", 60);
			LeaveRule("KW_SHORT", 60);
			LeaveRule_KW_SHORT();
		}
	}
	// $ANTLR end "KW_SHORT"

	partial void EnterRule_KW_SIZEOF();
	partial void LeaveRule_KW_SIZEOF();

	// $ANTLR start "KW_SIZEOF"
	[GrammarRule("KW_SIZEOF")]
	private void mKW_SIZEOF()
	{
		EnterRule_KW_SIZEOF();
		EnterRule("KW_SIZEOF", 61);
		TraceIn("KW_SIZEOF", 61);
		try
		{
			int _type = KW_SIZEOF;
			int _channel = DefaultTokenChannel;
			// Truss.g:2359:11: ( 'sizeof' )
			DebugEnterAlt(1);
			// Truss.g:2359:13: 'sizeof'
			{
			DebugLocation(2359, 13);
			Match("sizeof"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_SIZEOF", 61);
			LeaveRule("KW_SIZEOF", 61);
			LeaveRule_KW_SIZEOF();
		}
	}
	// $ANTLR end "KW_SIZEOF"

	partial void EnterRule_KW_STATIC();
	partial void LeaveRule_KW_STATIC();

	// $ANTLR start "KW_STATIC"
	[GrammarRule("KW_STATIC")]
	private void mKW_STATIC()
	{
		EnterRule_KW_STATIC();
		EnterRule("KW_STATIC", 62);
		TraceIn("KW_STATIC", 62);
		try
		{
			int _type = KW_STATIC;
			int _channel = DefaultTokenChannel;
			// Truss.g:2360:11: ( 'static' )
			DebugEnterAlt(1);
			// Truss.g:2360:13: 'static'
			{
			DebugLocation(2360, 13);
			Match("static"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_STATIC", 62);
			LeaveRule("KW_STATIC", 62);
			LeaveRule_KW_STATIC();
		}
	}
	// $ANTLR end "KW_STATIC"

	partial void EnterRule_KW_STRING();
	partial void LeaveRule_KW_STRING();

	// $ANTLR start "KW_STRING"
	[GrammarRule("KW_STRING")]
	private void mKW_STRING()
	{
		EnterRule_KW_STRING();
		EnterRule("KW_STRING", 63);
		TraceIn("KW_STRING", 63);
		try
		{
			int _type = KW_STRING;
			int _channel = DefaultTokenChannel;
			// Truss.g:2361:11: ( 'string' )
			DebugEnterAlt(1);
			// Truss.g:2361:13: 'string'
			{
			DebugLocation(2361, 13);
			Match("string"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_STRING", 63);
			LeaveRule("KW_STRING", 63);
			LeaveRule_KW_STRING();
		}
	}
	// $ANTLR end "KW_STRING"

	partial void EnterRule_KW_STRUCT();
	partial void LeaveRule_KW_STRUCT();

	// $ANTLR start "KW_STRUCT"
	[GrammarRule("KW_STRUCT")]
	private void mKW_STRUCT()
	{
		EnterRule_KW_STRUCT();
		EnterRule("KW_STRUCT", 64);
		TraceIn("KW_STRUCT", 64);
		try
		{
			int _type = KW_STRUCT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2362:11: ( 'struct' )
			DebugEnterAlt(1);
			// Truss.g:2362:13: 'struct'
			{
			DebugLocation(2362, 13);
			Match("struct"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_STRUCT", 64);
			LeaveRule("KW_STRUCT", 64);
			LeaveRule_KW_STRUCT();
		}
	}
	// $ANTLR end "KW_STRUCT"

	partial void EnterRule_KW_SWITCH();
	partial void LeaveRule_KW_SWITCH();

	// $ANTLR start "KW_SWITCH"
	[GrammarRule("KW_SWITCH")]
	private void mKW_SWITCH()
	{
		EnterRule_KW_SWITCH();
		EnterRule("KW_SWITCH", 65);
		TraceIn("KW_SWITCH", 65);
		try
		{
			int _type = KW_SWITCH;
			int _channel = DefaultTokenChannel;
			// Truss.g:2363:11: ( 'switch' )
			DebugEnterAlt(1);
			// Truss.g:2363:13: 'switch'
			{
			DebugLocation(2363, 13);
			Match("switch"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_SWITCH", 65);
			LeaveRule("KW_SWITCH", 65);
			LeaveRule_KW_SWITCH();
		}
	}
	// $ANTLR end "KW_SWITCH"

	partial void EnterRule_KW_THIS();
	partial void LeaveRule_KW_THIS();

	// $ANTLR start "KW_THIS"
	[GrammarRule("KW_THIS")]
	private void mKW_THIS()
	{
		EnterRule_KW_THIS();
		EnterRule("KW_THIS", 66);
		TraceIn("KW_THIS", 66);
		try
		{
			int _type = KW_THIS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2364:9: ( 'this' )
			DebugEnterAlt(1);
			// Truss.g:2364:11: 'this'
			{
			DebugLocation(2364, 11);
			Match("this"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_THIS", 66);
			LeaveRule("KW_THIS", 66);
			LeaveRule_KW_THIS();
		}
	}
	// $ANTLR end "KW_THIS"

	partial void EnterRule_KW_THROW();
	partial void LeaveRule_KW_THROW();

	// $ANTLR start "KW_THROW"
	[GrammarRule("KW_THROW")]
	private void mKW_THROW()
	{
		EnterRule_KW_THROW();
		EnterRule("KW_THROW", 67);
		TraceIn("KW_THROW", 67);
		try
		{
			int _type = KW_THROW;
			int _channel = DefaultTokenChannel;
			// Truss.g:2365:10: ( 'throw' )
			DebugEnterAlt(1);
			// Truss.g:2365:12: 'throw'
			{
			DebugLocation(2365, 12);
			Match("throw"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_THROW", 67);
			LeaveRule("KW_THROW", 67);
			LeaveRule_KW_THROW();
		}
	}
	// $ANTLR end "KW_THROW"

	partial void EnterRule_KW_TRUE();
	partial void LeaveRule_KW_TRUE();

	// $ANTLR start "KW_TRUE"
	[GrammarRule("KW_TRUE")]
	private void mKW_TRUE()
	{
		EnterRule_KW_TRUE();
		EnterRule("KW_TRUE", 68);
		TraceIn("KW_TRUE", 68);
		try
		{
			int _type = KW_TRUE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2366:9: ( 'true' )
			DebugEnterAlt(1);
			// Truss.g:2366:11: 'true'
			{
			DebugLocation(2366, 11);
			Match("true"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_TRUE", 68);
			LeaveRule("KW_TRUE", 68);
			LeaveRule_KW_TRUE();
		}
	}
	// $ANTLR end "KW_TRUE"

	partial void EnterRule_KW_TRY();
	partial void LeaveRule_KW_TRY();

	// $ANTLR start "KW_TRY"
	[GrammarRule("KW_TRY")]
	private void mKW_TRY()
	{
		EnterRule_KW_TRY();
		EnterRule("KW_TRY", 69);
		TraceIn("KW_TRY", 69);
		try
		{
			int _type = KW_TRY;
			int _channel = DefaultTokenChannel;
			// Truss.g:2367:8: ( 'try' )
			DebugEnterAlt(1);
			// Truss.g:2367:10: 'try'
			{
			DebugLocation(2367, 10);
			Match("try"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_TRY", 69);
			LeaveRule("KW_TRY", 69);
			LeaveRule_KW_TRY();
		}
	}
	// $ANTLR end "KW_TRY"

	partial void EnterRule_KW_TYPEOF();
	partial void LeaveRule_KW_TYPEOF();

	// $ANTLR start "KW_TYPEOF"
	[GrammarRule("KW_TYPEOF")]
	private void mKW_TYPEOF()
	{
		EnterRule_KW_TYPEOF();
		EnterRule("KW_TYPEOF", 70);
		TraceIn("KW_TYPEOF", 70);
		try
		{
			int _type = KW_TYPEOF;
			int _channel = DefaultTokenChannel;
			// Truss.g:2368:11: ( 'typeof' )
			DebugEnterAlt(1);
			// Truss.g:2368:13: 'typeof'
			{
			DebugLocation(2368, 13);
			Match("typeof"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_TYPEOF", 70);
			LeaveRule("KW_TYPEOF", 70);
			LeaveRule_KW_TYPEOF();
		}
	}
	// $ANTLR end "KW_TYPEOF"

	partial void EnterRule_KW_UINT();
	partial void LeaveRule_KW_UINT();

	// $ANTLR start "KW_UINT"
	[GrammarRule("KW_UINT")]
	private void mKW_UINT()
	{
		EnterRule_KW_UINT();
		EnterRule("KW_UINT", 71);
		TraceIn("KW_UINT", 71);
		try
		{
			int _type = KW_UINT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2369:9: ( 'uint' )
			DebugEnterAlt(1);
			// Truss.g:2369:11: 'uint'
			{
			DebugLocation(2369, 11);
			Match("uint"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_UINT", 71);
			LeaveRule("KW_UINT", 71);
			LeaveRule_KW_UINT();
		}
	}
	// $ANTLR end "KW_UINT"

	partial void EnterRule_KW_ULONG();
	partial void LeaveRule_KW_ULONG();

	// $ANTLR start "KW_ULONG"
	[GrammarRule("KW_ULONG")]
	private void mKW_ULONG()
	{
		EnterRule_KW_ULONG();
		EnterRule("KW_ULONG", 72);
		TraceIn("KW_ULONG", 72);
		try
		{
			int _type = KW_ULONG;
			int _channel = DefaultTokenChannel;
			// Truss.g:2370:10: ( 'ulong' )
			DebugEnterAlt(1);
			// Truss.g:2370:12: 'ulong'
			{
			DebugLocation(2370, 12);
			Match("ulong"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_ULONG", 72);
			LeaveRule("KW_ULONG", 72);
			LeaveRule_KW_ULONG();
		}
	}
	// $ANTLR end "KW_ULONG"

	partial void EnterRule_KW_USHORT();
	partial void LeaveRule_KW_USHORT();

	// $ANTLR start "KW_USHORT"
	[GrammarRule("KW_USHORT")]
	private void mKW_USHORT()
	{
		EnterRule_KW_USHORT();
		EnterRule("KW_USHORT", 73);
		TraceIn("KW_USHORT", 73);
		try
		{
			int _type = KW_USHORT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2371:11: ( 'ushort' )
			DebugEnterAlt(1);
			// Truss.g:2371:13: 'ushort'
			{
			DebugLocation(2371, 13);
			Match("ushort"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_USHORT", 73);
			LeaveRule("KW_USHORT", 73);
			LeaveRule_KW_USHORT();
		}
	}
	// $ANTLR end "KW_USHORT"

	partial void EnterRule_KW_USING();
	partial void LeaveRule_KW_USING();

	// $ANTLR start "KW_USING"
	[GrammarRule("KW_USING")]
	private void mKW_USING()
	{
		EnterRule_KW_USING();
		EnterRule("KW_USING", 74);
		TraceIn("KW_USING", 74);
		try
		{
			int _type = KW_USING;
			int _channel = DefaultTokenChannel;
			// Truss.g:2372:10: ( 'using' )
			DebugEnterAlt(1);
			// Truss.g:2372:12: 'using'
			{
			DebugLocation(2372, 12);
			Match("using"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_USING", 74);
			LeaveRule("KW_USING", 74);
			LeaveRule_KW_USING();
		}
	}
	// $ANTLR end "KW_USING"

	partial void EnterRule_KW_VAR();
	partial void LeaveRule_KW_VAR();

	// $ANTLR start "KW_VAR"
	[GrammarRule("KW_VAR")]
	private void mKW_VAR()
	{
		EnterRule_KW_VAR();
		EnterRule("KW_VAR", 75);
		TraceIn("KW_VAR", 75);
		try
		{
			int _type = KW_VAR;
			int _channel = DefaultTokenChannel;
			// Truss.g:2373:8: ( 'var' )
			DebugEnterAlt(1);
			// Truss.g:2373:10: 'var'
			{
			DebugLocation(2373, 10);
			Match("var"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_VAR", 75);
			LeaveRule("KW_VAR", 75);
			LeaveRule_KW_VAR();
		}
	}
	// $ANTLR end "KW_VAR"

	partial void EnterRule_KW_VIRTUAL();
	partial void LeaveRule_KW_VIRTUAL();

	// $ANTLR start "KW_VIRTUAL"
	[GrammarRule("KW_VIRTUAL")]
	private void mKW_VIRTUAL()
	{
		EnterRule_KW_VIRTUAL();
		EnterRule("KW_VIRTUAL", 76);
		TraceIn("KW_VIRTUAL", 76);
		try
		{
			int _type = KW_VIRTUAL;
			int _channel = DefaultTokenChannel;
			// Truss.g:2374:12: ( 'virtual' )
			DebugEnterAlt(1);
			// Truss.g:2374:14: 'virtual'
			{
			DebugLocation(2374, 14);
			Match("virtual"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_VIRTUAL", 76);
			LeaveRule("KW_VIRTUAL", 76);
			LeaveRule_KW_VIRTUAL();
		}
	}
	// $ANTLR end "KW_VIRTUAL"

	partial void EnterRule_KW_VOID();
	partial void LeaveRule_KW_VOID();

	// $ANTLR start "KW_VOID"
	[GrammarRule("KW_VOID")]
	private void mKW_VOID()
	{
		EnterRule_KW_VOID();
		EnterRule("KW_VOID", 77);
		TraceIn("KW_VOID", 77);
		try
		{
			int _type = KW_VOID;
			int _channel = DefaultTokenChannel;
			// Truss.g:2375:9: ( 'void' )
			DebugEnterAlt(1);
			// Truss.g:2375:11: 'void'
			{
			DebugLocation(2375, 11);
			Match("void"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_VOID", 77);
			LeaveRule("KW_VOID", 77);
			LeaveRule_KW_VOID();
		}
	}
	// $ANTLR end "KW_VOID"

	partial void EnterRule_KW_VOLATILE();
	partial void LeaveRule_KW_VOLATILE();

	// $ANTLR start "KW_VOLATILE"
	[GrammarRule("KW_VOLATILE")]
	private void mKW_VOLATILE()
	{
		EnterRule_KW_VOLATILE();
		EnterRule("KW_VOLATILE", 78);
		TraceIn("KW_VOLATILE", 78);
		try
		{
			int _type = KW_VOLATILE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2376:13: ( 'volatile' )
			DebugEnterAlt(1);
			// Truss.g:2376:15: 'volatile'
			{
			DebugLocation(2376, 15);
			Match("volatile"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_VOLATILE", 78);
			LeaveRule("KW_VOLATILE", 78);
			LeaveRule_KW_VOLATILE();
		}
	}
	// $ANTLR end "KW_VOLATILE"

	partial void EnterRule_KW_WHERE();
	partial void LeaveRule_KW_WHERE();

	// $ANTLR start "KW_WHERE"
	[GrammarRule("KW_WHERE")]
	private void mKW_WHERE()
	{
		EnterRule_KW_WHERE();
		EnterRule("KW_WHERE", 79);
		TraceIn("KW_WHERE", 79);
		try
		{
			int _type = KW_WHERE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2377:10: ( 'where' )
			DebugEnterAlt(1);
			// Truss.g:2377:12: 'where'
			{
			DebugLocation(2377, 12);
			Match("where"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_WHERE", 79);
			LeaveRule("KW_WHERE", 79);
			LeaveRule_KW_WHERE();
		}
	}
	// $ANTLR end "KW_WHERE"

	partial void EnterRule_KW_WHILE();
	partial void LeaveRule_KW_WHILE();

	// $ANTLR start "KW_WHILE"
	[GrammarRule("KW_WHILE")]
	private void mKW_WHILE()
	{
		EnterRule_KW_WHILE();
		EnterRule("KW_WHILE", 80);
		TraceIn("KW_WHILE", 80);
		try
		{
			int _type = KW_WHILE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2378:10: ( 'while' )
			DebugEnterAlt(1);
			// Truss.g:2378:12: 'while'
			{
			DebugLocation(2378, 12);
			Match("while"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("KW_WHILE", 80);
			LeaveRule("KW_WHILE", 80);
			LeaveRule_KW_WHILE();
		}
	}
	// $ANTLR end "KW_WHILE"

	partial void EnterRule_OP_AMPERSAND();
	partial void LeaveRule_OP_AMPERSAND();

	// $ANTLR start "OP_AMPERSAND"
	[GrammarRule("OP_AMPERSAND")]
	private void mOP_AMPERSAND()
	{
		EnterRule_OP_AMPERSAND();
		EnterRule("OP_AMPERSAND", 81);
		TraceIn("OP_AMPERSAND", 81);
		try
		{
			int _type = OP_AMPERSAND;
			int _channel = DefaultTokenChannel;
			// Truss.g:2380:14: ( '&' )
			DebugEnterAlt(1);
			// Truss.g:2380:16: '&'
			{
			DebugLocation(2380, 16);
			Match('&'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_AMPERSAND", 81);
			LeaveRule("OP_AMPERSAND", 81);
			LeaveRule_OP_AMPERSAND();
		}
	}
	// $ANTLR end "OP_AMPERSAND"

	partial void EnterRule_OP_AMPERSAND_AMPERSAND();
	partial void LeaveRule_OP_AMPERSAND_AMPERSAND();

	// $ANTLR start "OP_AMPERSAND_AMPERSAND"
	[GrammarRule("OP_AMPERSAND_AMPERSAND")]
	private void mOP_AMPERSAND_AMPERSAND()
	{
		EnterRule_OP_AMPERSAND_AMPERSAND();
		EnterRule("OP_AMPERSAND_AMPERSAND", 82);
		TraceIn("OP_AMPERSAND_AMPERSAND", 82);
		try
		{
			int _type = OP_AMPERSAND_AMPERSAND;
			int _channel = DefaultTokenChannel;
			// Truss.g:2381:24: ( '&&' )
			DebugEnterAlt(1);
			// Truss.g:2381:26: '&&'
			{
			DebugLocation(2381, 26);
			Match("&&"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_AMPERSAND_AMPERSAND", 82);
			LeaveRule("OP_AMPERSAND_AMPERSAND", 82);
			LeaveRule_OP_AMPERSAND_AMPERSAND();
		}
	}
	// $ANTLR end "OP_AMPERSAND_AMPERSAND"

	partial void EnterRule_OP_AMPERSAND_EQUALS();
	partial void LeaveRule_OP_AMPERSAND_EQUALS();

	// $ANTLR start "OP_AMPERSAND_EQUALS"
	[GrammarRule("OP_AMPERSAND_EQUALS")]
	private void mOP_AMPERSAND_EQUALS()
	{
		EnterRule_OP_AMPERSAND_EQUALS();
		EnterRule("OP_AMPERSAND_EQUALS", 83);
		TraceIn("OP_AMPERSAND_EQUALS", 83);
		try
		{
			int _type = OP_AMPERSAND_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2382:21: ( '&=' )
			DebugEnterAlt(1);
			// Truss.g:2382:23: '&='
			{
			DebugLocation(2382, 23);
			Match("&="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_AMPERSAND_EQUALS", 83);
			LeaveRule("OP_AMPERSAND_EQUALS", 83);
			LeaveRule_OP_AMPERSAND_EQUALS();
		}
	}
	// $ANTLR end "OP_AMPERSAND_EQUALS"

	partial void EnterRule_OP_ASTERISK();
	partial void LeaveRule_OP_ASTERISK();

	// $ANTLR start "OP_ASTERISK"
	[GrammarRule("OP_ASTERISK")]
	private void mOP_ASTERISK()
	{
		EnterRule_OP_ASTERISK();
		EnterRule("OP_ASTERISK", 84);
		TraceIn("OP_ASTERISK", 84);
		try
		{
			int _type = OP_ASTERISK;
			int _channel = DefaultTokenChannel;
			// Truss.g:2383:13: ( '*' )
			DebugEnterAlt(1);
			// Truss.g:2383:15: '*'
			{
			DebugLocation(2383, 15);
			Match('*'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_ASTERISK", 84);
			LeaveRule("OP_ASTERISK", 84);
			LeaveRule_OP_ASTERISK();
		}
	}
	// $ANTLR end "OP_ASTERISK"

	partial void EnterRule_OP_ASTERISK_EQUALS();
	partial void LeaveRule_OP_ASTERISK_EQUALS();

	// $ANTLR start "OP_ASTERISK_EQUALS"
	[GrammarRule("OP_ASTERISK_EQUALS")]
	private void mOP_ASTERISK_EQUALS()
	{
		EnterRule_OP_ASTERISK_EQUALS();
		EnterRule("OP_ASTERISK_EQUALS", 85);
		TraceIn("OP_ASTERISK_EQUALS", 85);
		try
		{
			int _type = OP_ASTERISK_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2384:20: ( '*=' )
			DebugEnterAlt(1);
			// Truss.g:2384:22: '*='
			{
			DebugLocation(2384, 22);
			Match("*="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_ASTERISK_EQUALS", 85);
			LeaveRule("OP_ASTERISK_EQUALS", 85);
			LeaveRule_OP_ASTERISK_EQUALS();
		}
	}
	// $ANTLR end "OP_ASTERISK_EQUALS"

	partial void EnterRule_OP_BAR();
	partial void LeaveRule_OP_BAR();

	// $ANTLR start "OP_BAR"
	[GrammarRule("OP_BAR")]
	private void mOP_BAR()
	{
		EnterRule_OP_BAR();
		EnterRule("OP_BAR", 86);
		TraceIn("OP_BAR", 86);
		try
		{
			int _type = OP_BAR;
			int _channel = DefaultTokenChannel;
			// Truss.g:2385:8: ( '|' )
			DebugEnterAlt(1);
			// Truss.g:2385:10: '|'
			{
			DebugLocation(2385, 10);
			Match('|'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_BAR", 86);
			LeaveRule("OP_BAR", 86);
			LeaveRule_OP_BAR();
		}
	}
	// $ANTLR end "OP_BAR"

	partial void EnterRule_OP_BAR_BAR();
	partial void LeaveRule_OP_BAR_BAR();

	// $ANTLR start "OP_BAR_BAR"
	[GrammarRule("OP_BAR_BAR")]
	private void mOP_BAR_BAR()
	{
		EnterRule_OP_BAR_BAR();
		EnterRule("OP_BAR_BAR", 87);
		TraceIn("OP_BAR_BAR", 87);
		try
		{
			int _type = OP_BAR_BAR;
			int _channel = DefaultTokenChannel;
			// Truss.g:2386:12: ( '||' )
			DebugEnterAlt(1);
			// Truss.g:2386:14: '||'
			{
			DebugLocation(2386, 14);
			Match("||"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_BAR_BAR", 87);
			LeaveRule("OP_BAR_BAR", 87);
			LeaveRule_OP_BAR_BAR();
		}
	}
	// $ANTLR end "OP_BAR_BAR"

	partial void EnterRule_OP_BAR_EQUALS();
	partial void LeaveRule_OP_BAR_EQUALS();

	// $ANTLR start "OP_BAR_EQUALS"
	[GrammarRule("OP_BAR_EQUALS")]
	private void mOP_BAR_EQUALS()
	{
		EnterRule_OP_BAR_EQUALS();
		EnterRule("OP_BAR_EQUALS", 88);
		TraceIn("OP_BAR_EQUALS", 88);
		try
		{
			int _type = OP_BAR_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2387:15: ( '|=' )
			DebugEnterAlt(1);
			// Truss.g:2387:17: '|='
			{
			DebugLocation(2387, 17);
			Match("|="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_BAR_EQUALS", 88);
			LeaveRule("OP_BAR_EQUALS", 88);
			LeaveRule_OP_BAR_EQUALS();
		}
	}
	// $ANTLR end "OP_BAR_EQUALS"

	partial void EnterRule_OP_BRACE_CLOSE();
	partial void LeaveRule_OP_BRACE_CLOSE();

	// $ANTLR start "OP_BRACE_CLOSE"
	[GrammarRule("OP_BRACE_CLOSE")]
	private void mOP_BRACE_CLOSE()
	{
		EnterRule_OP_BRACE_CLOSE();
		EnterRule("OP_BRACE_CLOSE", 89);
		TraceIn("OP_BRACE_CLOSE", 89);
		try
		{
			int _type = OP_BRACE_CLOSE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2388:16: ( '}' )
			DebugEnterAlt(1);
			// Truss.g:2388:18: '}'
			{
			DebugLocation(2388, 18);
			Match('}'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_BRACE_CLOSE", 89);
			LeaveRule("OP_BRACE_CLOSE", 89);
			LeaveRule_OP_BRACE_CLOSE();
		}
	}
	// $ANTLR end "OP_BRACE_CLOSE"

	partial void EnterRule_OP_BRACE_OPEN();
	partial void LeaveRule_OP_BRACE_OPEN();

	// $ANTLR start "OP_BRACE_OPEN"
	[GrammarRule("OP_BRACE_OPEN")]
	private void mOP_BRACE_OPEN()
	{
		EnterRule_OP_BRACE_OPEN();
		EnterRule("OP_BRACE_OPEN", 90);
		TraceIn("OP_BRACE_OPEN", 90);
		try
		{
			int _type = OP_BRACE_OPEN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2389:15: ( '{' )
			DebugEnterAlt(1);
			// Truss.g:2389:17: '{'
			{
			DebugLocation(2389, 17);
			Match('{'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_BRACE_OPEN", 90);
			LeaveRule("OP_BRACE_OPEN", 90);
			LeaveRule_OP_BRACE_OPEN();
		}
	}
	// $ANTLR end "OP_BRACE_OPEN"

	partial void EnterRule_OP_BRACKET_CLOSE();
	partial void LeaveRule_OP_BRACKET_CLOSE();

	// $ANTLR start "OP_BRACKET_CLOSE"
	[GrammarRule("OP_BRACKET_CLOSE")]
	private void mOP_BRACKET_CLOSE()
	{
		EnterRule_OP_BRACKET_CLOSE();
		EnterRule("OP_BRACKET_CLOSE", 91);
		TraceIn("OP_BRACKET_CLOSE", 91);
		try
		{
			int _type = OP_BRACKET_CLOSE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2390:18: ( ']' )
			DebugEnterAlt(1);
			// Truss.g:2390:20: ']'
			{
			DebugLocation(2390, 20);
			Match(']'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_BRACKET_CLOSE", 91);
			LeaveRule("OP_BRACKET_CLOSE", 91);
			LeaveRule_OP_BRACKET_CLOSE();
		}
	}
	// $ANTLR end "OP_BRACKET_CLOSE"

	partial void EnterRule_OP_BRACKET_OPEN();
	partial void LeaveRule_OP_BRACKET_OPEN();

	// $ANTLR start "OP_BRACKET_OPEN"
	[GrammarRule("OP_BRACKET_OPEN")]
	private void mOP_BRACKET_OPEN()
	{
		EnterRule_OP_BRACKET_OPEN();
		EnterRule("OP_BRACKET_OPEN", 92);
		TraceIn("OP_BRACKET_OPEN", 92);
		try
		{
			int _type = OP_BRACKET_OPEN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2391:17: ( '[' )
			DebugEnterAlt(1);
			// Truss.g:2391:19: '['
			{
			DebugLocation(2391, 19);
			Match('['); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_BRACKET_OPEN", 92);
			LeaveRule("OP_BRACKET_OPEN", 92);
			LeaveRule_OP_BRACKET_OPEN();
		}
	}
	// $ANTLR end "OP_BRACKET_OPEN"

	partial void EnterRule_OP_CARET();
	partial void LeaveRule_OP_CARET();

	// $ANTLR start "OP_CARET"
	[GrammarRule("OP_CARET")]
	private void mOP_CARET()
	{
		EnterRule_OP_CARET();
		EnterRule("OP_CARET", 93);
		TraceIn("OP_CARET", 93);
		try
		{
			int _type = OP_CARET;
			int _channel = DefaultTokenChannel;
			// Truss.g:2392:10: ( '^' )
			DebugEnterAlt(1);
			// Truss.g:2392:12: '^'
			{
			DebugLocation(2392, 12);
			Match('^'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_CARET", 93);
			LeaveRule("OP_CARET", 93);
			LeaveRule_OP_CARET();
		}
	}
	// $ANTLR end "OP_CARET"

	partial void EnterRule_OP_CARET_EQUALS();
	partial void LeaveRule_OP_CARET_EQUALS();

	// $ANTLR start "OP_CARET_EQUALS"
	[GrammarRule("OP_CARET_EQUALS")]
	private void mOP_CARET_EQUALS()
	{
		EnterRule_OP_CARET_EQUALS();
		EnterRule("OP_CARET_EQUALS", 94);
		TraceIn("OP_CARET_EQUALS", 94);
		try
		{
			int _type = OP_CARET_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2393:17: ( '^=' )
			DebugEnterAlt(1);
			// Truss.g:2393:19: '^='
			{
			DebugLocation(2393, 19);
			Match("^="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_CARET_EQUALS", 94);
			LeaveRule("OP_CARET_EQUALS", 94);
			LeaveRule_OP_CARET_EQUALS();
		}
	}
	// $ANTLR end "OP_CARET_EQUALS"

	partial void EnterRule_OP_COLON();
	partial void LeaveRule_OP_COLON();

	// $ANTLR start "OP_COLON"
	[GrammarRule("OP_COLON")]
	private void mOP_COLON()
	{
		EnterRule_OP_COLON();
		EnterRule("OP_COLON", 95);
		TraceIn("OP_COLON", 95);
		try
		{
			int _type = OP_COLON;
			int _channel = DefaultTokenChannel;
			// Truss.g:2394:10: ( ':' )
			DebugEnterAlt(1);
			// Truss.g:2394:12: ':'
			{
			DebugLocation(2394, 12);
			Match(':'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_COLON", 95);
			LeaveRule("OP_COLON", 95);
			LeaveRule_OP_COLON();
		}
	}
	// $ANTLR end "OP_COLON"

	partial void EnterRule_OP_COLON_COLON();
	partial void LeaveRule_OP_COLON_COLON();

	// $ANTLR start "OP_COLON_COLON"
	[GrammarRule("OP_COLON_COLON")]
	private void mOP_COLON_COLON()
	{
		EnterRule_OP_COLON_COLON();
		EnterRule("OP_COLON_COLON", 96);
		TraceIn("OP_COLON_COLON", 96);
		try
		{
			int _type = OP_COLON_COLON;
			int _channel = DefaultTokenChannel;
			// Truss.g:2395:16: ( '::' )
			DebugEnterAlt(1);
			// Truss.g:2395:18: '::'
			{
			DebugLocation(2395, 18);
			Match("::"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_COLON_COLON", 96);
			LeaveRule("OP_COLON_COLON", 96);
			LeaveRule_OP_COLON_COLON();
		}
	}
	// $ANTLR end "OP_COLON_COLON"

	partial void EnterRule_OP_COMMA();
	partial void LeaveRule_OP_COMMA();

	// $ANTLR start "OP_COMMA"
	[GrammarRule("OP_COMMA")]
	private void mOP_COMMA()
	{
		EnterRule_OP_COMMA();
		EnterRule("OP_COMMA", 97);
		TraceIn("OP_COMMA", 97);
		try
		{
			int _type = OP_COMMA;
			int _channel = DefaultTokenChannel;
			// Truss.g:2396:10: ( ',' )
			DebugEnterAlt(1);
			// Truss.g:2396:12: ','
			{
			DebugLocation(2396, 12);
			Match(','); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_COMMA", 97);
			LeaveRule("OP_COMMA", 97);
			LeaveRule_OP_COMMA();
		}
	}
	// $ANTLR end "OP_COMMA"

	partial void EnterRule_OP_DOT();
	partial void LeaveRule_OP_DOT();

	// $ANTLR start "OP_DOT"
	[GrammarRule("OP_DOT")]
	private void mOP_DOT()
	{
		EnterRule_OP_DOT();
		EnterRule("OP_DOT", 98);
		TraceIn("OP_DOT", 98);
		try
		{
			int _type = OP_DOT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2397:8: ( '.' )
			DebugEnterAlt(1);
			// Truss.g:2397:10: '.'
			{
			DebugLocation(2397, 10);
			Match('.'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_DOT", 98);
			LeaveRule("OP_DOT", 98);
			LeaveRule_OP_DOT();
		}
	}
	// $ANTLR end "OP_DOT"

	partial void EnterRule_OP_EQUALS();
	partial void LeaveRule_OP_EQUALS();

	// $ANTLR start "OP_EQUALS"
	[GrammarRule("OP_EQUALS")]
	private void mOP_EQUALS()
	{
		EnterRule_OP_EQUALS();
		EnterRule("OP_EQUALS", 99);
		TraceIn("OP_EQUALS", 99);
		try
		{
			int _type = OP_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2398:11: ( '=' )
			DebugEnterAlt(1);
			// Truss.g:2398:13: '='
			{
			DebugLocation(2398, 13);
			Match('='); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_EQUALS", 99);
			LeaveRule("OP_EQUALS", 99);
			LeaveRule_OP_EQUALS();
		}
	}
	// $ANTLR end "OP_EQUALS"

	partial void EnterRule_OP_EQUALS_EQUALS();
	partial void LeaveRule_OP_EQUALS_EQUALS();

	// $ANTLR start "OP_EQUALS_EQUALS"
	[GrammarRule("OP_EQUALS_EQUALS")]
	private void mOP_EQUALS_EQUALS()
	{
		EnterRule_OP_EQUALS_EQUALS();
		EnterRule("OP_EQUALS_EQUALS", 100);
		TraceIn("OP_EQUALS_EQUALS", 100);
		try
		{
			int _type = OP_EQUALS_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2399:18: ( '==' )
			DebugEnterAlt(1);
			// Truss.g:2399:20: '=='
			{
			DebugLocation(2399, 20);
			Match("=="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_EQUALS_EQUALS", 100);
			LeaveRule("OP_EQUALS_EQUALS", 100);
			LeaveRule_OP_EQUALS_EQUALS();
		}
	}
	// $ANTLR end "OP_EQUALS_EQUALS"

	partial void EnterRule_OP_EQUALS_GREATER_THAN();
	partial void LeaveRule_OP_EQUALS_GREATER_THAN();

	// $ANTLR start "OP_EQUALS_GREATER_THAN"
	[GrammarRule("OP_EQUALS_GREATER_THAN")]
	private void mOP_EQUALS_GREATER_THAN()
	{
		EnterRule_OP_EQUALS_GREATER_THAN();
		EnterRule("OP_EQUALS_GREATER_THAN", 101);
		TraceIn("OP_EQUALS_GREATER_THAN", 101);
		try
		{
			int _type = OP_EQUALS_GREATER_THAN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2400:24: ( '=>' )
			DebugEnterAlt(1);
			// Truss.g:2400:26: '=>'
			{
			DebugLocation(2400, 26);
			Match("=>"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_EQUALS_GREATER_THAN", 101);
			LeaveRule("OP_EQUALS_GREATER_THAN", 101);
			LeaveRule_OP_EQUALS_GREATER_THAN();
		}
	}
	// $ANTLR end "OP_EQUALS_GREATER_THAN"

	partial void EnterRule_OP_EXCLAMATION();
	partial void LeaveRule_OP_EXCLAMATION();

	// $ANTLR start "OP_EXCLAMATION"
	[GrammarRule("OP_EXCLAMATION")]
	private void mOP_EXCLAMATION()
	{
		EnterRule_OP_EXCLAMATION();
		EnterRule("OP_EXCLAMATION", 102);
		TraceIn("OP_EXCLAMATION", 102);
		try
		{
			int _type = OP_EXCLAMATION;
			int _channel = DefaultTokenChannel;
			// Truss.g:2401:16: ( '!' )
			DebugEnterAlt(1);
			// Truss.g:2401:18: '!'
			{
			DebugLocation(2401, 18);
			Match('!'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_EXCLAMATION", 102);
			LeaveRule("OP_EXCLAMATION", 102);
			LeaveRule_OP_EXCLAMATION();
		}
	}
	// $ANTLR end "OP_EXCLAMATION"

	partial void EnterRule_OP_EXCLAMATION_EQUALS();
	partial void LeaveRule_OP_EXCLAMATION_EQUALS();

	// $ANTLR start "OP_EXCLAMATION_EQUALS"
	[GrammarRule("OP_EXCLAMATION_EQUALS")]
	private void mOP_EXCLAMATION_EQUALS()
	{
		EnterRule_OP_EXCLAMATION_EQUALS();
		EnterRule("OP_EXCLAMATION_EQUALS", 103);
		TraceIn("OP_EXCLAMATION_EQUALS", 103);
		try
		{
			int _type = OP_EXCLAMATION_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2402:23: ( '!=' )
			DebugEnterAlt(1);
			// Truss.g:2402:25: '!='
			{
			DebugLocation(2402, 25);
			Match("!="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_EXCLAMATION_EQUALS", 103);
			LeaveRule("OP_EXCLAMATION_EQUALS", 103);
			LeaveRule_OP_EXCLAMATION_EQUALS();
		}
	}
	// $ANTLR end "OP_EXCLAMATION_EQUALS"

	partial void EnterRule_OP_GREATER_THAN();
	partial void LeaveRule_OP_GREATER_THAN();

	// $ANTLR start "OP_GREATER_THAN"
	[GrammarRule("OP_GREATER_THAN")]
	private void mOP_GREATER_THAN()
	{
		EnterRule_OP_GREATER_THAN();
		EnterRule("OP_GREATER_THAN", 104);
		TraceIn("OP_GREATER_THAN", 104);
		try
		{
			int _type = OP_GREATER_THAN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2403:17: ( '>' )
			DebugEnterAlt(1);
			// Truss.g:2403:19: '>'
			{
			DebugLocation(2403, 19);
			Match('>'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_GREATER_THAN", 104);
			LeaveRule("OP_GREATER_THAN", 104);
			LeaveRule_OP_GREATER_THAN();
		}
	}
	// $ANTLR end "OP_GREATER_THAN"

	partial void EnterRule_OP_GREATER_THAN_EQUALS();
	partial void LeaveRule_OP_GREATER_THAN_EQUALS();

	// $ANTLR start "OP_GREATER_THAN_EQUALS"
	[GrammarRule("OP_GREATER_THAN_EQUALS")]
	private void mOP_GREATER_THAN_EQUALS()
	{
		EnterRule_OP_GREATER_THAN_EQUALS();
		EnterRule("OP_GREATER_THAN_EQUALS", 105);
		TraceIn("OP_GREATER_THAN_EQUALS", 105);
		try
		{
			int _type = OP_GREATER_THAN_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2404:24: ( '>=' )
			DebugEnterAlt(1);
			// Truss.g:2404:26: '>='
			{
			DebugLocation(2404, 26);
			Match(">="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_GREATER_THAN_EQUALS", 105);
			LeaveRule("OP_GREATER_THAN_EQUALS", 105);
			LeaveRule_OP_GREATER_THAN_EQUALS();
		}
	}
	// $ANTLR end "OP_GREATER_THAN_EQUALS"

	partial void EnterRule_OP_GREATER_THAN_GREATER_THAN();
	partial void LeaveRule_OP_GREATER_THAN_GREATER_THAN();

	// $ANTLR start "OP_GREATER_THAN_GREATER_THAN"
	[GrammarRule("OP_GREATER_THAN_GREATER_THAN")]
	private void mOP_GREATER_THAN_GREATER_THAN()
	{
		EnterRule_OP_GREATER_THAN_GREATER_THAN();
		EnterRule("OP_GREATER_THAN_GREATER_THAN", 106);
		TraceIn("OP_GREATER_THAN_GREATER_THAN", 106);
		try
		{
			int _type = OP_GREATER_THAN_GREATER_THAN;
			int _channel = DefaultTokenChannel;
			CommonToken t = default(CommonToken);

			// Truss.g:2405:30: (t= '>>' )
			DebugEnterAlt(1);
			// Truss.g:2405:32: t= '>>'
			{
			DebugLocation(2405, 33);
			int tStart = CharIndex;
			Match(">>"); if (state.failed) return;
			int tStartLine883 = Line;
			int tStartCharPos883 = CharPositionInLine;
			t = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, tStart, CharIndex-1);
			t.Line = tStartLine883;
			t.CharPositionInLine = tStartCharPos883;
			DebugLocation(2405, 39);
			if (state.backtracking == 0)
			{
				 EmitGreaterThanGreaterThan(t); 
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_GREATER_THAN_GREATER_THAN", 106);
			LeaveRule("OP_GREATER_THAN_GREATER_THAN", 106);
			LeaveRule_OP_GREATER_THAN_GREATER_THAN();
		}
	}
	// $ANTLR end "OP_GREATER_THAN_GREATER_THAN"

	partial void EnterRule_OP_GREATER_THAN_GREATER_THAN_EQUALS();
	partial void LeaveRule_OP_GREATER_THAN_GREATER_THAN_EQUALS();

	// $ANTLR start "OP_GREATER_THAN_GREATER_THAN_EQUALS"
	[GrammarRule("OP_GREATER_THAN_GREATER_THAN_EQUALS")]
	private void mOP_GREATER_THAN_GREATER_THAN_EQUALS()
	{
		EnterRule_OP_GREATER_THAN_GREATER_THAN_EQUALS();
		EnterRule("OP_GREATER_THAN_GREATER_THAN_EQUALS", 107);
		TraceIn("OP_GREATER_THAN_GREATER_THAN_EQUALS", 107);
		try
		{
			int _type = OP_GREATER_THAN_GREATER_THAN_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2406:37: ( '>>=' )
			DebugEnterAlt(1);
			// Truss.g:2406:39: '>>='
			{
			DebugLocation(2406, 39);
			Match(">>="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_GREATER_THAN_GREATER_THAN_EQUALS", 107);
			LeaveRule("OP_GREATER_THAN_GREATER_THAN_EQUALS", 107);
			LeaveRule_OP_GREATER_THAN_GREATER_THAN_EQUALS();
		}
	}
	// $ANTLR end "OP_GREATER_THAN_GREATER_THAN_EQUALS"

	partial void EnterRule_OP_LESS_THAN();
	partial void LeaveRule_OP_LESS_THAN();

	// $ANTLR start "OP_LESS_THAN"
	[GrammarRule("OP_LESS_THAN")]
	private void mOP_LESS_THAN()
	{
		EnterRule_OP_LESS_THAN();
		EnterRule("OP_LESS_THAN", 108);
		TraceIn("OP_LESS_THAN", 108);
		try
		{
			int _type = OP_LESS_THAN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2407:14: ( '<' )
			DebugEnterAlt(1);
			// Truss.g:2407:16: '<'
			{
			DebugLocation(2407, 16);
			Match('<'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_LESS_THAN", 108);
			LeaveRule("OP_LESS_THAN", 108);
			LeaveRule_OP_LESS_THAN();
		}
	}
	// $ANTLR end "OP_LESS_THAN"

	partial void EnterRule_OP_LESS_THAN_EQUALS();
	partial void LeaveRule_OP_LESS_THAN_EQUALS();

	// $ANTLR start "OP_LESS_THAN_EQUALS"
	[GrammarRule("OP_LESS_THAN_EQUALS")]
	private void mOP_LESS_THAN_EQUALS()
	{
		EnterRule_OP_LESS_THAN_EQUALS();
		EnterRule("OP_LESS_THAN_EQUALS", 109);
		TraceIn("OP_LESS_THAN_EQUALS", 109);
		try
		{
			int _type = OP_LESS_THAN_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2408:21: ( '<=' )
			DebugEnterAlt(1);
			// Truss.g:2408:23: '<='
			{
			DebugLocation(2408, 23);
			Match("<="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_LESS_THAN_EQUALS", 109);
			LeaveRule("OP_LESS_THAN_EQUALS", 109);
			LeaveRule_OP_LESS_THAN_EQUALS();
		}
	}
	// $ANTLR end "OP_LESS_THAN_EQUALS"

	partial void EnterRule_OP_LESS_THAN_LESS_THAN();
	partial void LeaveRule_OP_LESS_THAN_LESS_THAN();

	// $ANTLR start "OP_LESS_THAN_LESS_THAN"
	[GrammarRule("OP_LESS_THAN_LESS_THAN")]
	private void mOP_LESS_THAN_LESS_THAN()
	{
		EnterRule_OP_LESS_THAN_LESS_THAN();
		EnterRule("OP_LESS_THAN_LESS_THAN", 110);
		TraceIn("OP_LESS_THAN_LESS_THAN", 110);
		try
		{
			int _type = OP_LESS_THAN_LESS_THAN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2409:24: ( '<<' )
			DebugEnterAlt(1);
			// Truss.g:2409:26: '<<'
			{
			DebugLocation(2409, 26);
			Match("<<"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_LESS_THAN_LESS_THAN", 110);
			LeaveRule("OP_LESS_THAN_LESS_THAN", 110);
			LeaveRule_OP_LESS_THAN_LESS_THAN();
		}
	}
	// $ANTLR end "OP_LESS_THAN_LESS_THAN"

	partial void EnterRule_OP_LESS_THAN_LESS_THAN_EQUALS();
	partial void LeaveRule_OP_LESS_THAN_LESS_THAN_EQUALS();

	// $ANTLR start "OP_LESS_THAN_LESS_THAN_EQUALS"
	[GrammarRule("OP_LESS_THAN_LESS_THAN_EQUALS")]
	private void mOP_LESS_THAN_LESS_THAN_EQUALS()
	{
		EnterRule_OP_LESS_THAN_LESS_THAN_EQUALS();
		EnterRule("OP_LESS_THAN_LESS_THAN_EQUALS", 111);
		TraceIn("OP_LESS_THAN_LESS_THAN_EQUALS", 111);
		try
		{
			int _type = OP_LESS_THAN_LESS_THAN_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2410:31: ( '<<=' )
			DebugEnterAlt(1);
			// Truss.g:2410:33: '<<='
			{
			DebugLocation(2410, 33);
			Match("<<="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_LESS_THAN_LESS_THAN_EQUALS", 111);
			LeaveRule("OP_LESS_THAN_LESS_THAN_EQUALS", 111);
			LeaveRule_OP_LESS_THAN_LESS_THAN_EQUALS();
		}
	}
	// $ANTLR end "OP_LESS_THAN_LESS_THAN_EQUALS"

	partial void EnterRule_OP_MINUS();
	partial void LeaveRule_OP_MINUS();

	// $ANTLR start "OP_MINUS"
	[GrammarRule("OP_MINUS")]
	private void mOP_MINUS()
	{
		EnterRule_OP_MINUS();
		EnterRule("OP_MINUS", 112);
		TraceIn("OP_MINUS", 112);
		try
		{
			int _type = OP_MINUS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2411:10: ( '-' )
			DebugEnterAlt(1);
			// Truss.g:2411:12: '-'
			{
			DebugLocation(2411, 12);
			Match('-'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_MINUS", 112);
			LeaveRule("OP_MINUS", 112);
			LeaveRule_OP_MINUS();
		}
	}
	// $ANTLR end "OP_MINUS"

	partial void EnterRule_OP_MINUS_EQUALS();
	partial void LeaveRule_OP_MINUS_EQUALS();

	// $ANTLR start "OP_MINUS_EQUALS"
	[GrammarRule("OP_MINUS_EQUALS")]
	private void mOP_MINUS_EQUALS()
	{
		EnterRule_OP_MINUS_EQUALS();
		EnterRule("OP_MINUS_EQUALS", 113);
		TraceIn("OP_MINUS_EQUALS", 113);
		try
		{
			int _type = OP_MINUS_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2412:17: ( '-=' )
			DebugEnterAlt(1);
			// Truss.g:2412:19: '-='
			{
			DebugLocation(2412, 19);
			Match("-="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_MINUS_EQUALS", 113);
			LeaveRule("OP_MINUS_EQUALS", 113);
			LeaveRule_OP_MINUS_EQUALS();
		}
	}
	// $ANTLR end "OP_MINUS_EQUALS"

	partial void EnterRule_OP_MINUS_MINUS();
	partial void LeaveRule_OP_MINUS_MINUS();

	// $ANTLR start "OP_MINUS_MINUS"
	[GrammarRule("OP_MINUS_MINUS")]
	private void mOP_MINUS_MINUS()
	{
		EnterRule_OP_MINUS_MINUS();
		EnterRule("OP_MINUS_MINUS", 114);
		TraceIn("OP_MINUS_MINUS", 114);
		try
		{
			int _type = OP_MINUS_MINUS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2413:16: ( '--' )
			DebugEnterAlt(1);
			// Truss.g:2413:18: '--'
			{
			DebugLocation(2413, 18);
			Match("--"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_MINUS_MINUS", 114);
			LeaveRule("OP_MINUS_MINUS", 114);
			LeaveRule_OP_MINUS_MINUS();
		}
	}
	// $ANTLR end "OP_MINUS_MINUS"

	partial void EnterRule_OP_PAREN_CLOSE();
	partial void LeaveRule_OP_PAREN_CLOSE();

	// $ANTLR start "OP_PAREN_CLOSE"
	[GrammarRule("OP_PAREN_CLOSE")]
	private void mOP_PAREN_CLOSE()
	{
		EnterRule_OP_PAREN_CLOSE();
		EnterRule("OP_PAREN_CLOSE", 115);
		TraceIn("OP_PAREN_CLOSE", 115);
		try
		{
			int _type = OP_PAREN_CLOSE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2414:16: ( ')' )
			DebugEnterAlt(1);
			// Truss.g:2414:18: ')'
			{
			DebugLocation(2414, 18);
			Match(')'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_PAREN_CLOSE", 115);
			LeaveRule("OP_PAREN_CLOSE", 115);
			LeaveRule_OP_PAREN_CLOSE();
		}
	}
	// $ANTLR end "OP_PAREN_CLOSE"

	partial void EnterRule_OP_PAREN_OPEN();
	partial void LeaveRule_OP_PAREN_OPEN();

	// $ANTLR start "OP_PAREN_OPEN"
	[GrammarRule("OP_PAREN_OPEN")]
	private void mOP_PAREN_OPEN()
	{
		EnterRule_OP_PAREN_OPEN();
		EnterRule("OP_PAREN_OPEN", 116);
		TraceIn("OP_PAREN_OPEN", 116);
		try
		{
			int _type = OP_PAREN_OPEN;
			int _channel = DefaultTokenChannel;
			// Truss.g:2415:15: ( '(' )
			DebugEnterAlt(1);
			// Truss.g:2415:17: '('
			{
			DebugLocation(2415, 17);
			Match('('); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_PAREN_OPEN", 116);
			LeaveRule("OP_PAREN_OPEN", 116);
			LeaveRule_OP_PAREN_OPEN();
		}
	}
	// $ANTLR end "OP_PAREN_OPEN"

	partial void EnterRule_OP_PERCENT();
	partial void LeaveRule_OP_PERCENT();

	// $ANTLR start "OP_PERCENT"
	[GrammarRule("OP_PERCENT")]
	private void mOP_PERCENT()
	{
		EnterRule_OP_PERCENT();
		EnterRule("OP_PERCENT", 117);
		TraceIn("OP_PERCENT", 117);
		try
		{
			int _type = OP_PERCENT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2416:12: ( '%' )
			DebugEnterAlt(1);
			// Truss.g:2416:14: '%'
			{
			DebugLocation(2416, 14);
			Match('%'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_PERCENT", 117);
			LeaveRule("OP_PERCENT", 117);
			LeaveRule_OP_PERCENT();
		}
	}
	// $ANTLR end "OP_PERCENT"

	partial void EnterRule_OP_PERCENT_EQUALS();
	partial void LeaveRule_OP_PERCENT_EQUALS();

	// $ANTLR start "OP_PERCENT_EQUALS"
	[GrammarRule("OP_PERCENT_EQUALS")]
	private void mOP_PERCENT_EQUALS()
	{
		EnterRule_OP_PERCENT_EQUALS();
		EnterRule("OP_PERCENT_EQUALS", 118);
		TraceIn("OP_PERCENT_EQUALS", 118);
		try
		{
			int _type = OP_PERCENT_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2417:19: ( '%=' )
			DebugEnterAlt(1);
			// Truss.g:2417:21: '%='
			{
			DebugLocation(2417, 21);
			Match("%="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_PERCENT_EQUALS", 118);
			LeaveRule("OP_PERCENT_EQUALS", 118);
			LeaveRule_OP_PERCENT_EQUALS();
		}
	}
	// $ANTLR end "OP_PERCENT_EQUALS"

	partial void EnterRule_OP_PLUS();
	partial void LeaveRule_OP_PLUS();

	// $ANTLR start "OP_PLUS"
	[GrammarRule("OP_PLUS")]
	private void mOP_PLUS()
	{
		EnterRule_OP_PLUS();
		EnterRule("OP_PLUS", 119);
		TraceIn("OP_PLUS", 119);
		try
		{
			int _type = OP_PLUS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2418:9: ( '+' )
			DebugEnterAlt(1);
			// Truss.g:2418:11: '+'
			{
			DebugLocation(2418, 11);
			Match('+'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_PLUS", 119);
			LeaveRule("OP_PLUS", 119);
			LeaveRule_OP_PLUS();
		}
	}
	// $ANTLR end "OP_PLUS"

	partial void EnterRule_OP_PLUS_EQUALS();
	partial void LeaveRule_OP_PLUS_EQUALS();

	// $ANTLR start "OP_PLUS_EQUALS"
	[GrammarRule("OP_PLUS_EQUALS")]
	private void mOP_PLUS_EQUALS()
	{
		EnterRule_OP_PLUS_EQUALS();
		EnterRule("OP_PLUS_EQUALS", 120);
		TraceIn("OP_PLUS_EQUALS", 120);
		try
		{
			int _type = OP_PLUS_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2419:16: ( '+=' )
			DebugEnterAlt(1);
			// Truss.g:2419:18: '+='
			{
			DebugLocation(2419, 18);
			Match("+="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_PLUS_EQUALS", 120);
			LeaveRule("OP_PLUS_EQUALS", 120);
			LeaveRule_OP_PLUS_EQUALS();
		}
	}
	// $ANTLR end "OP_PLUS_EQUALS"

	partial void EnterRule_OP_PLUS_PLUS();
	partial void LeaveRule_OP_PLUS_PLUS();

	// $ANTLR start "OP_PLUS_PLUS"
	[GrammarRule("OP_PLUS_PLUS")]
	private void mOP_PLUS_PLUS()
	{
		EnterRule_OP_PLUS_PLUS();
		EnterRule("OP_PLUS_PLUS", 121);
		TraceIn("OP_PLUS_PLUS", 121);
		try
		{
			int _type = OP_PLUS_PLUS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2420:14: ( '++' )
			DebugEnterAlt(1);
			// Truss.g:2420:16: '++'
			{
			DebugLocation(2420, 16);
			Match("++"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_PLUS_PLUS", 121);
			LeaveRule("OP_PLUS_PLUS", 121);
			LeaveRule_OP_PLUS_PLUS();
		}
	}
	// $ANTLR end "OP_PLUS_PLUS"

	partial void EnterRule_OP_QUESTION();
	partial void LeaveRule_OP_QUESTION();

	// $ANTLR start "OP_QUESTION"
	[GrammarRule("OP_QUESTION")]
	private void mOP_QUESTION()
	{
		EnterRule_OP_QUESTION();
		EnterRule("OP_QUESTION", 122);
		TraceIn("OP_QUESTION", 122);
		try
		{
			int _type = OP_QUESTION;
			int _channel = DefaultTokenChannel;
			// Truss.g:2421:13: ( '?' )
			DebugEnterAlt(1);
			// Truss.g:2421:15: '?'
			{
			DebugLocation(2421, 15);
			Match('?'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_QUESTION", 122);
			LeaveRule("OP_QUESTION", 122);
			LeaveRule_OP_QUESTION();
		}
	}
	// $ANTLR end "OP_QUESTION"

	partial void EnterRule_OP_QUESTION_QUESTION();
	partial void LeaveRule_OP_QUESTION_QUESTION();

	// $ANTLR start "OP_QUESTION_QUESTION"
	[GrammarRule("OP_QUESTION_QUESTION")]
	private void mOP_QUESTION_QUESTION()
	{
		EnterRule_OP_QUESTION_QUESTION();
		EnterRule("OP_QUESTION_QUESTION", 123);
		TraceIn("OP_QUESTION_QUESTION", 123);
		try
		{
			int _type = OP_QUESTION_QUESTION;
			int _channel = DefaultTokenChannel;
			// Truss.g:2422:22: ( '??' )
			DebugEnterAlt(1);
			// Truss.g:2422:24: '??'
			{
			DebugLocation(2422, 24);
			Match("??"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_QUESTION_QUESTION", 123);
			LeaveRule("OP_QUESTION_QUESTION", 123);
			LeaveRule_OP_QUESTION_QUESTION();
		}
	}
	// $ANTLR end "OP_QUESTION_QUESTION"

	partial void EnterRule_OP_SEMICOLON();
	partial void LeaveRule_OP_SEMICOLON();

	// $ANTLR start "OP_SEMICOLON"
	[GrammarRule("OP_SEMICOLON")]
	private void mOP_SEMICOLON()
	{
		EnterRule_OP_SEMICOLON();
		EnterRule("OP_SEMICOLON", 124);
		TraceIn("OP_SEMICOLON", 124);
		try
		{
			int _type = OP_SEMICOLON;
			int _channel = DefaultTokenChannel;
			// Truss.g:2423:14: ( ';' )
			DebugEnterAlt(1);
			// Truss.g:2423:16: ';'
			{
			DebugLocation(2423, 16);
			Match(';'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_SEMICOLON", 124);
			LeaveRule("OP_SEMICOLON", 124);
			LeaveRule_OP_SEMICOLON();
		}
	}
	// $ANTLR end "OP_SEMICOLON"

	partial void EnterRule_OP_SLASH();
	partial void LeaveRule_OP_SLASH();

	// $ANTLR start "OP_SLASH"
	[GrammarRule("OP_SLASH")]
	private void mOP_SLASH()
	{
		EnterRule_OP_SLASH();
		EnterRule("OP_SLASH", 125);
		TraceIn("OP_SLASH", 125);
		try
		{
			int _type = OP_SLASH;
			int _channel = DefaultTokenChannel;
			// Truss.g:2424:10: ( '/' )
			DebugEnterAlt(1);
			// Truss.g:2424:12: '/'
			{
			DebugLocation(2424, 12);
			Match('/'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_SLASH", 125);
			LeaveRule("OP_SLASH", 125);
			LeaveRule_OP_SLASH();
		}
	}
	// $ANTLR end "OP_SLASH"

	partial void EnterRule_OP_SLASH_EQUALS();
	partial void LeaveRule_OP_SLASH_EQUALS();

	// $ANTLR start "OP_SLASH_EQUALS"
	[GrammarRule("OP_SLASH_EQUALS")]
	private void mOP_SLASH_EQUALS()
	{
		EnterRule_OP_SLASH_EQUALS();
		EnterRule("OP_SLASH_EQUALS", 126);
		TraceIn("OP_SLASH_EQUALS", 126);
		try
		{
			int _type = OP_SLASH_EQUALS;
			int _channel = DefaultTokenChannel;
			// Truss.g:2425:17: ( '/=' )
			DebugEnterAlt(1);
			// Truss.g:2425:19: '/='
			{
			DebugLocation(2425, 19);
			Match("/="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_SLASH_EQUALS", 126);
			LeaveRule("OP_SLASH_EQUALS", 126);
			LeaveRule_OP_SLASH_EQUALS();
		}
	}
	// $ANTLR end "OP_SLASH_EQUALS"

	partial void EnterRule_OP_TILDE();
	partial void LeaveRule_OP_TILDE();

	// $ANTLR start "OP_TILDE"
	[GrammarRule("OP_TILDE")]
	private void mOP_TILDE()
	{
		EnterRule_OP_TILDE();
		EnterRule("OP_TILDE", 127);
		TraceIn("OP_TILDE", 127);
		try
		{
			int _type = OP_TILDE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2426:10: ( '~' )
			DebugEnterAlt(1);
			// Truss.g:2426:12: '~'
			{
			DebugLocation(2426, 12);
			Match('~'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OP_TILDE", 127);
			LeaveRule("OP_TILDE", 127);
			LeaveRule_OP_TILDE();
		}
	}
	// $ANTLR end "OP_TILDE"

	partial void EnterRule_OP_GREATER_THAN_GREATER_THAN_FIRST();
	partial void LeaveRule_OP_GREATER_THAN_GREATER_THAN_FIRST();

	// $ANTLR start "OP_GREATER_THAN_GREATER_THAN_FIRST"
	[GrammarRule("OP_GREATER_THAN_GREATER_THAN_FIRST")]
	private void mOP_GREATER_THAN_GREATER_THAN_FIRST()
	{
		EnterRule_OP_GREATER_THAN_GREATER_THAN_FIRST();
		EnterRule("OP_GREATER_THAN_GREATER_THAN_FIRST", 128);
		TraceIn("OP_GREATER_THAN_GREATER_THAN_FIRST", 128);
		try
		{
			// Truss.g:2435:45: ()
			DebugEnterAlt(1);
			// Truss.g:2435:47: 
			{
			}

		}
		finally
		{
			TraceOut("OP_GREATER_THAN_GREATER_THAN_FIRST", 128);
			LeaveRule("OP_GREATER_THAN_GREATER_THAN_FIRST", 128);
			LeaveRule_OP_GREATER_THAN_GREATER_THAN_FIRST();
		}
	}
	// $ANTLR end "OP_GREATER_THAN_GREATER_THAN_FIRST"

	partial void EnterRule_OP_GREATER_THAN_GREATER_THAN_SECOND();
	partial void LeaveRule_OP_GREATER_THAN_GREATER_THAN_SECOND();

	// $ANTLR start "OP_GREATER_THAN_GREATER_THAN_SECOND"
	[GrammarRule("OP_GREATER_THAN_GREATER_THAN_SECOND")]
	private void mOP_GREATER_THAN_GREATER_THAN_SECOND()
	{
		EnterRule_OP_GREATER_THAN_GREATER_THAN_SECOND();
		EnterRule("OP_GREATER_THAN_GREATER_THAN_SECOND", 129);
		TraceIn("OP_GREATER_THAN_GREATER_THAN_SECOND", 129);
		try
		{
			// Truss.g:2436:46: ()
			DebugEnterAlt(1);
			// Truss.g:2436:48: 
			{
			}

		}
		finally
		{
			TraceOut("OP_GREATER_THAN_GREATER_THAN_SECOND", 129);
			LeaveRule("OP_GREATER_THAN_GREATER_THAN_SECOND", 129);
			LeaveRule_OP_GREATER_THAN_GREATER_THAN_SECOND();
		}
	}
	// $ANTLR end "OP_GREATER_THAN_GREATER_THAN_SECOND"

	partial void EnterRule_NEW_LINE();
	partial void LeaveRule_NEW_LINE();

	// $ANTLR start "NEW_LINE"
	[GrammarRule("NEW_LINE")]
	private void mNEW_LINE()
	{
		EnterRule_NEW_LINE();
		EnterRule("NEW_LINE", 130);
		TraceIn("NEW_LINE", 130);
		try
		{
			int _type = NEW_LINE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2441:5: ( ( '\\r' | '\\n' | '\\r\\n' | '\\u0085' | '\\u2028' | '\\u2029' ) )
			DebugEnterAlt(1);
			// Truss.g:2442:5: ( '\\r' | '\\n' | '\\r\\n' | '\\u0085' | '\\u2028' | '\\u2029' )
			{
			DebugLocation(2442, 5);
			// Truss.g:2442:5: ( '\\r' | '\\n' | '\\r\\n' | '\\u0085' | '\\u2028' | '\\u2029' )
			int alt1=6;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case '\r':
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='\n'))
				{
					alt1 = 3;
				}
				else
				{
					alt1 = 1;
				}
				}
				break;
			case '\n':
				{
				alt1 = 2;
				}
				break;
			case '\u0085':
				{
				alt1 = 4;
				}
				break;
			case '\u2028':
				{
				alt1 = 5;
				}
				break;
			case '\u2029':
				{
				alt1 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Truss.g:2442:7: '\\r'
				{
				DebugLocation(2442, 7);
				Match('\r'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Truss.g:2443:7: '\\n'
				{
				DebugLocation(2443, 7);
				Match('\n'); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Truss.g:2444:7: '\\r\\n'
				{
				DebugLocation(2444, 7);
				Match("\r\n"); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Truss.g:2445:7: '\\u0085'
				{
				DebugLocation(2445, 7);
				Match('\u0085'); if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Truss.g:2446:7: '\\u2028'
				{
				DebugLocation(2446, 7);
				Match('\u2028'); if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Truss.g:2447:7: '\\u2029'
				{
				DebugLocation(2447, 7);
				Match('\u2029'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(2449, 5);
			if (state.backtracking == 0)
			{
				 Skip(); 
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEW_LINE", 130);
			LeaveRule("NEW_LINE", 130);
			LeaveRule_NEW_LINE();
		}
	}
	// $ANTLR end "NEW_LINE"

	partial void EnterRule_NEW_LINE_CHARACTER();
	partial void LeaveRule_NEW_LINE_CHARACTER();

	// $ANTLR start "NEW_LINE_CHARACTER"
	[GrammarRule("NEW_LINE_CHARACTER")]
	private void mNEW_LINE_CHARACTER()
	{
		EnterRule_NEW_LINE_CHARACTER();
		EnterRule("NEW_LINE_CHARACTER", 131);
		TraceIn("NEW_LINE_CHARACTER", 131);
		try
		{
			// Truss.g:2453:5: ( '\\r' | '\\n' | '\\u0085' | '\\u2028' | '\\u2029' )
			DebugEnterAlt(1);
			// Truss.g:
			{
			DebugLocation(2453, 5);
			if (input.LA(1)=='\n'||input.LA(1)=='\r'||input.LA(1)=='\u0085'||(input.LA(1)>='\u2028' && input.LA(1)<='\u2029'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("NEW_LINE_CHARACTER", 131);
			LeaveRule("NEW_LINE_CHARACTER", 131);
			LeaveRule_NEW_LINE_CHARACTER();
		}
	}
	// $ANTLR end "NEW_LINE_CHARACTER"

	partial void EnterRule_INPUT_CHARACTER();
	partial void LeaveRule_INPUT_CHARACTER();

	// $ANTLR start "INPUT_CHARACTER"
	[GrammarRule("INPUT_CHARACTER")]
	private void mINPUT_CHARACTER()
	{
		EnterRule_INPUT_CHARACTER();
		EnterRule("INPUT_CHARACTER", 132);
		TraceIn("INPUT_CHARACTER", 132);
		try
		{
			// Truss.g:2460:26: (~ NEW_LINE_CHARACTER )
			DebugEnterAlt(1);
			// Truss.g:
			{
			DebugLocation(2460, 26);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='\t')||(input.LA(1)>='\u000B' && input.LA(1)<='\f')||(input.LA(1)>='\u000E' && input.LA(1)<='\u0084')||(input.LA(1)>='\u0086' && input.LA(1)<='\u2027')||(input.LA(1)>='\u202A' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("INPUT_CHARACTER", 132);
			LeaveRule("INPUT_CHARACTER", 132);
			LeaveRule_INPUT_CHARACTER();
		}
	}
	// $ANTLR end "INPUT_CHARACTER"

	partial void EnterRule_LINE_COMMENT();
	partial void LeaveRule_LINE_COMMENT();

	// $ANTLR start "LINE_COMMENT"
	[GrammarRule("LINE_COMMENT")]
	private void mLINE_COMMENT()
	{
		EnterRule_LINE_COMMENT();
		EnterRule("LINE_COMMENT", 133);
		TraceIn("LINE_COMMENT", 133);
		try
		{
			int _type = LINE_COMMENT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2463:5: ( '//' ( INPUT_CHARACTER )* )
			DebugEnterAlt(1);
			// Truss.g:2464:9: '//' ( INPUT_CHARACTER )*
			{
			DebugLocation(2464, 9);
			Match("//"); if (state.failed) return;

			DebugLocation(2464, 14);
			// Truss.g:2464:14: ( INPUT_CHARACTER )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if (((LA2_1>='\u0000' && LA2_1<='\t')||(LA2_1>='\u000B' && LA2_1<='\f')||(LA2_1>='\u000E' && LA2_1<='\u0084')||(LA2_1>='\u0086' && LA2_1<='\u2027')||(LA2_1>='\u202A' && LA2_1<='\uFFFF')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:
					{
					DebugLocation(2464, 14);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(2465, 9);
			if (state.backtracking == 0)
			{
				 Skip(); 
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LINE_COMMENT", 133);
			LeaveRule("LINE_COMMENT", 133);
			LeaveRule_LINE_COMMENT();
		}
	}
	// $ANTLR end "LINE_COMMENT"

	partial void EnterRule_BLOCK_COMMENT();
	partial void LeaveRule_BLOCK_COMMENT();

	// $ANTLR start "BLOCK_COMMENT"
	[GrammarRule("BLOCK_COMMENT")]
	private void mBLOCK_COMMENT()
	{
		EnterRule_BLOCK_COMMENT();
		EnterRule("BLOCK_COMMENT", 134);
		TraceIn("BLOCK_COMMENT", 134);
		try
		{
			int _type = BLOCK_COMMENT;
			int _channel = DefaultTokenChannel;

			    bool docComment = false;

			// Truss.g:2472:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
			DebugEnterAlt(1);
			// Truss.g:2473:9: '/*' ( options {greedy=false; } : . )* '*/'
			{
			DebugLocation(2473, 9);
			Match("/*"); if (state.failed) return;

			DebugLocation(2474, 9);
			if (state.backtracking == 0)
			{
				 docComment = (char)input.LT(1) == '*'; 
			}
			DebugLocation(2475, 9);
			// Truss.g:2475:9: ( options {greedy=false; } : . )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1=='*'))
				{
					int LA3_2 = input.LA(2);

					if ((LA3_2=='/'))
					{
						alt3 = 2;
					}
					else if (((LA3_2>='\u0000' && LA3_2<='.')||(LA3_2>='0' && LA3_2<='\uFFFF')))
					{
						alt3 = 1;
					}


				}
				else if (((LA3_1>='\u0000' && LA3_1<=')')||(LA3_1>='+' && LA3_1<='\uFFFF')))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:2475:39: .
					{
					DebugLocation(2475, 39);
					MatchAny(); if (state.failed) return;

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(2476, 9);
			Match("*/"); if (state.failed) return;

			DebugLocation(2477, 9);
			if (state.backtracking == 0)
			{

				            if (docComment) {
				                _channel = Hidden;
				            } else {
				                Skip();
				            }
				        
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BLOCK_COMMENT", 134);
			LeaveRule("BLOCK_COMMENT", 134);
			LeaveRule_BLOCK_COMMENT();
		}
	}
	// $ANTLR end "BLOCK_COMMENT"

	partial void EnterRule_WHITESPACE();
	partial void LeaveRule_WHITESPACE();

	// $ANTLR start "WHITESPACE"
	[GrammarRule("WHITESPACE")]
	private void mWHITESPACE()
	{
		EnterRule_WHITESPACE();
		EnterRule("WHITESPACE", 135);
		TraceIn("WHITESPACE", 135);
		try
		{
			int _type = WHITESPACE;
			int _channel = DefaultTokenChannel;
			// Truss.g:2487:5: ( ( ' ' | '\\t' | '\\v' | '\\f' ) )
			DebugEnterAlt(1);
			// Truss.g:2488:5: ( ' ' | '\\t' | '\\v' | '\\f' )
			{
			DebugLocation(2488, 5);
			if (input.LA(1)=='\t'||input.LA(1)=='\f'||input.LA(1)==' '||input.LA(1)=='v')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(2493, 5);
			if (state.backtracking == 0)
			{
				 Skip(); 
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHITESPACE", 135);
			LeaveRule("WHITESPACE", 135);
			LeaveRule_WHITESPACE();
		}
	}
	// $ANTLR end "WHITESPACE"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 136);
		TraceIn("DIGIT", 136);
		try
		{
			// Truss.g:2496:16: ( '0' .. '9' )
			DebugEnterAlt(1);
			// Truss.g:
			{
			DebugLocation(2496, 16);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("DIGIT", 136);
			LeaveRule("DIGIT", 136);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_HEX_DIGIT();
	partial void LeaveRule_HEX_DIGIT();

	// $ANTLR start "HEX_DIGIT"
	[GrammarRule("HEX_DIGIT")]
	private void mHEX_DIGIT()
	{
		EnterRule_HEX_DIGIT();
		EnterRule("HEX_DIGIT", 137);
		TraceIn("HEX_DIGIT", 137);
		try
		{
			// Truss.g:2497:20: ( DIGIT | 'a' .. 'f' | 'A' .. 'F' )
			DebugEnterAlt(1);
			// Truss.g:
			{
			DebugLocation(2497, 20);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("HEX_DIGIT", 137);
			LeaveRule("HEX_DIGIT", 137);
			LeaveRule_HEX_DIGIT();
		}
	}
	// $ANTLR end "HEX_DIGIT"

	partial void EnterRule_IDENTIFIER_FIRST_CHARACTER();
	partial void LeaveRule_IDENTIFIER_FIRST_CHARACTER();

	// $ANTLR start "IDENTIFIER_FIRST_CHARACTER"
	[GrammarRule("IDENTIFIER_FIRST_CHARACTER")]
	private void mIDENTIFIER_FIRST_CHARACTER()
	{
		EnterRule_IDENTIFIER_FIRST_CHARACTER();
		EnterRule("IDENTIFIER_FIRST_CHARACTER", 138);
		TraceIn("IDENTIFIER_FIRST_CHARACTER", 138);
		try
		{
			// Truss.g:2498:37: ( 'a' .. 'z' | 'A' .. 'Z' | '_' )
			DebugEnterAlt(1);
			// Truss.g:
			{
			DebugLocation(2498, 37);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("IDENTIFIER_FIRST_CHARACTER", 138);
			LeaveRule("IDENTIFIER_FIRST_CHARACTER", 138);
			LeaveRule_IDENTIFIER_FIRST_CHARACTER();
		}
	}
	// $ANTLR end "IDENTIFIER_FIRST_CHARACTER"

	partial void EnterRule_IDENTIFIER_CHARACTER();
	partial void LeaveRule_IDENTIFIER_CHARACTER();

	// $ANTLR start "IDENTIFIER_CHARACTER"
	[GrammarRule("IDENTIFIER_CHARACTER")]
	private void mIDENTIFIER_CHARACTER()
	{
		EnterRule_IDENTIFIER_CHARACTER();
		EnterRule("IDENTIFIER_CHARACTER", 139);
		TraceIn("IDENTIFIER_CHARACTER", 139);
		try
		{
			// Truss.g:2499:31: ( IDENTIFIER_FIRST_CHARACTER | DIGIT )
			DebugEnterAlt(1);
			// Truss.g:
			{
			DebugLocation(2499, 31);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("IDENTIFIER_CHARACTER", 139);
			LeaveRule("IDENTIFIER_CHARACTER", 139);
			LeaveRule_IDENTIFIER_CHARACTER();
		}
	}
	// $ANTLR end "IDENTIFIER_CHARACTER"

	partial void EnterRule_IDENTIFIER();
	partial void LeaveRule_IDENTIFIER();

	// $ANTLR start "IDENTIFIER"
	[GrammarRule("IDENTIFIER")]
	private void mIDENTIFIER()
	{
		EnterRule_IDENTIFIER();
		EnterRule("IDENTIFIER", 140);
		TraceIn("IDENTIFIER", 140);
		try
		{
			int _type = IDENTIFIER;
			int _channel = DefaultTokenChannel;
			// Truss.g:2501:12: ( ( '@' )? IDENTIFIER_FIRST_CHARACTER ( IDENTIFIER_CHARACTER )* )
			DebugEnterAlt(1);
			// Truss.g:2501:14: ( '@' )? IDENTIFIER_FIRST_CHARACTER ( IDENTIFIER_CHARACTER )*
			{
			DebugLocation(2501, 14);
			// Truss.g:2501:14: ( '@' )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1=='@'))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Truss.g:2501:14: '@'
				{
				DebugLocation(2501, 14);
				Match('@'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(2501, 19);
			mIDENTIFIER_FIRST_CHARACTER(); if (state.failed) return;
			DebugLocation(2501, 46);
			// Truss.g:2501:46: ( IDENTIFIER_CHARACTER )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if (((LA5_1>='0' && LA5_1<='9')||(LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z')))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:
					{
					DebugLocation(2501, 46);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IDENTIFIER", 140);
			LeaveRule("IDENTIFIER", 140);
			LeaveRule_IDENTIFIER();
		}
	}
	// $ANTLR end "IDENTIFIER"

	partial void EnterRule_INTEGER_SUFFIX();
	partial void LeaveRule_INTEGER_SUFFIX();

	// $ANTLR start "INTEGER_SUFFIX"
	[GrammarRule("INTEGER_SUFFIX")]
	private void mINTEGER_SUFFIX()
	{
		EnterRule_INTEGER_SUFFIX();
		EnterRule("INTEGER_SUFFIX", 141);
		TraceIn("INTEGER_SUFFIX", 141);
		try
		{
			// Truss.g:2504:5: ( ( 'u' | 'U' ) ( 'l' | 'L' )? | 'l' | 'L' )
			int alt7=3;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case 'U':
			case 'u':
				{
				alt7 = 1;
				}
				break;
			case 'l':
				{
				alt7 = 2;
				}
				break;
			case 'L':
				{
				alt7 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Truss.g:2504:7: ( 'u' | 'U' ) ( 'l' | 'L' )?
				{
				DebugLocation(2504, 7);
				input.Consume();
				state.failed=false;
				DebugLocation(2504, 21);
				// Truss.g:2504:21: ( 'l' | 'L' )?
				int alt6=2;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1=='L'||LA6_1=='l'))
				{
					alt6 = 1;
				}
				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:
					{
					DebugLocation(2504, 21);
					input.Consume();
					state.failed=false;

					}
					break;

				}
				} finally { DebugExitSubRule(6); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Truss.g:2505:7: 'l'
				{
				DebugLocation(2505, 7);
				Match('l'); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Truss.g:2505:13: 'L'
				{
				DebugLocation(2505, 13);
				Match('L'); if (state.failed) return;

				}
				break;

			}
		}
		finally
		{
			TraceOut("INTEGER_SUFFIX", 141);
			LeaveRule("INTEGER_SUFFIX", 141);
			LeaveRule_INTEGER_SUFFIX();
		}
	}
	// $ANTLR end "INTEGER_SUFFIX"

	partial void EnterRule_INTEGER();
	partial void LeaveRule_INTEGER();

	// $ANTLR start "INTEGER"
	[GrammarRule("INTEGER")]
	private void mINTEGER()
	{
		EnterRule_INTEGER();
		EnterRule("INTEGER", 142);
		TraceIn("INTEGER", 142);
		try
		{
			// Truss.g:2508:18: ()
			DebugEnterAlt(1);
			// Truss.g:2508:43: 
			{
			}

		}
		finally
		{
			TraceOut("INTEGER", 142);
			LeaveRule("INTEGER", 142);
			LeaveRule_INTEGER();
		}
	}
	// $ANTLR end "INTEGER"

	partial void EnterRule_HEX_INTEGER();
	partial void LeaveRule_HEX_INTEGER();

	// $ANTLR start "HEX_INTEGER"
	[GrammarRule("HEX_INTEGER")]
	private void mHEX_INTEGER()
	{
		EnterRule_HEX_INTEGER();
		EnterRule("HEX_INTEGER", 143);
		TraceIn("HEX_INTEGER", 143);
		try
		{
			int _type = HEX_INTEGER;
			int _channel = DefaultTokenChannel;
			// Truss.g:2509:13: ( '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( INTEGER_SUFFIX )? )
			DebugEnterAlt(1);
			// Truss.g:2509:15: '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( INTEGER_SUFFIX )?
			{
			DebugLocation(2509, 15);
			Match('0'); if (state.failed) return;
			DebugLocation(2509, 19);
			if (input.LA(1)=='X'||input.LA(1)=='x')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(2509, 33);
			// Truss.g:2509:33: ( HEX_DIGIT )+
			int cnt8=0;
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if (((LA8_1>='0' && LA8_1<='9')||(LA8_1>='A' && LA8_1<='F')||(LA8_1>='a' && LA8_1<='f')))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:
					{
					DebugLocation(2509, 33);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt8 >= 1)
						goto loop8;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee8 = new EarlyExitException( 8, input );
					DebugRecognitionException(eee8);
					throw eee8;
				}
				cnt8++;
			}
			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(2509, 44);
			// Truss.g:2509:44: ( INTEGER_SUFFIX )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1=='L'||LA9_1=='U'||LA9_1=='l'||LA9_1=='u'))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Truss.g:2509:44: INTEGER_SUFFIX
				{
				DebugLocation(2509, 44);
				mINTEGER_SUFFIX(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("HEX_INTEGER", 143);
			LeaveRule("HEX_INTEGER", 143);
			LeaveRule_HEX_INTEGER();
		}
	}
	// $ANTLR end "HEX_INTEGER"

	partial void EnterRule_EXPONENT();
	partial void LeaveRule_EXPONENT();

	// $ANTLR start "EXPONENT"
	[GrammarRule("EXPONENT")]
	private void mEXPONENT()
	{
		EnterRule_EXPONENT();
		EnterRule("EXPONENT", 144);
		TraceIn("EXPONENT", 144);
		try
		{
			// Truss.g:2511:19: ( ( 'e' | 'E' ) ( '+' | '-' )? ( DIGIT )+ )
			DebugEnterAlt(1);
			// Truss.g:2511:21: ( 'e' | 'E' ) ( '+' | '-' )? ( DIGIT )+
			{
			DebugLocation(2511, 21);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(2511, 35);
			// Truss.g:2511:35: ( '+' | '-' )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1=='+'||LA10_1=='-'))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Truss.g:
				{
				DebugLocation(2511, 35);
				input.Consume();
				state.failed=false;

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(2511, 50);
			// Truss.g:2511:50: ( DIGIT )+
			int cnt11=0;
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if (((LA11_1>='0' && LA11_1<='9')))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:
					{
					DebugLocation(2511, 50);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt11 >= 1)
						goto loop11;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee11 = new EarlyExitException( 11, input );
					DebugRecognitionException(eee11);
					throw eee11;
				}
				cnt11++;
			}
			loop11:
				;

			} finally { DebugExitSubRule(11); }


			}

		}
		finally
		{
			TraceOut("EXPONENT", 144);
			LeaveRule("EXPONENT", 144);
			LeaveRule_EXPONENT();
		}
	}
	// $ANTLR end "EXPONENT"

	partial void EnterRule_FLOAT_SUFFIX();
	partial void LeaveRule_FLOAT_SUFFIX();

	// $ANTLR start "FLOAT_SUFFIX"
	[GrammarRule("FLOAT_SUFFIX")]
	private void mFLOAT_SUFFIX()
	{
		EnterRule_FLOAT_SUFFIX();
		EnterRule("FLOAT_SUFFIX", 145);
		TraceIn("FLOAT_SUFFIX", 145);
		try
		{
			// Truss.g:2513:5: ( 'f' | 'F' | 'd' | 'D' | 'm' | 'M' )
			DebugEnterAlt(1);
			// Truss.g:
			{
			DebugLocation(2513, 5);
			if (input.LA(1)=='D'||input.LA(1)=='F'||input.LA(1)=='M'||input.LA(1)=='d'||input.LA(1)=='f'||input.LA(1)=='m')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("FLOAT_SUFFIX", 145);
			LeaveRule("FLOAT_SUFFIX", 145);
			LeaveRule_FLOAT_SUFFIX();
		}
	}
	// $ANTLR end "FLOAT_SUFFIX"

	partial void EnterRule_FLOAT();
	partial void LeaveRule_FLOAT();

	// $ANTLR start "FLOAT"
	[GrammarRule("FLOAT")]
	private void mFLOAT()
	{
		EnterRule_FLOAT();
		EnterRule("FLOAT", 146);
		TraceIn("FLOAT", 146);
		try
		{
			int _type = FLOAT;
			int _channel = DefaultTokenChannel;
			// Truss.g:2519:5: ( ( DIGIT )+ ( ( '.' DIGIT )=> ( '.' ( DIGIT )+ )? ( EXPONENT )? ( FLOAT_SUFFIX )? | FLOAT_SUFFIX |) | '.' ( DIGIT )+ ( EXPONENT )? ( FLOAT_SUFFIX )? )
			int alt21=2;
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if (((LA21_1>='0' && LA21_1<='9')))
			{
				alt21 = 1;
			}
			else if ((LA21_1=='.'))
			{
				alt21 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// Truss.g:2520:9: ( DIGIT )+ ( ( '.' DIGIT )=> ( '.' ( DIGIT )+ )? ( EXPONENT )? ( FLOAT_SUFFIX )? | FLOAT_SUFFIX |)
				{
				DebugLocation(2520, 9);
				// Truss.g:2520:9: ( DIGIT )+
				int cnt12=0;
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_1 = input.LA(1);

					if (((LA12_1>='0' && LA12_1<='9')))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch (alt12)
					{
					case 1:
						DebugEnterAlt(1);
						// Truss.g:
						{
						DebugLocation(2520, 9);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt12 >= 1)
							goto loop12;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee12 = new EarlyExitException( 12, input );
						DebugRecognitionException(eee12);
						throw eee12;
					}
					cnt12++;
				}
				loop12:
					;

				} finally { DebugExitSubRule(12); }

				DebugLocation(2521, 9);
				// Truss.g:2521:9: ( ( '.' DIGIT )=> ( '.' ( DIGIT )+ )? ( EXPONENT )? ( FLOAT_SUFFIX )? | FLOAT_SUFFIX |)
				int alt17=3;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1=='.') && (EvaluatePredicate(synpred1_Truss_fragment)))
				{
					alt17 = 1;
				}
				else if ((LA17_1=='E'||LA17_1=='e') && (EvaluatePredicate(synpred1_Truss_fragment)))
				{
					alt17 = 1;
				}
				else if ((LA17_1=='D'||LA17_1=='F'||LA17_1=='M'||LA17_1=='d'||LA17_1=='f'||LA17_1=='m'))
				{
					int LA17_2 = input.LA(2);

					if ((EvaluatePredicate(synpred1_Truss_fragment)))
					{
						alt17 = 1;
					}
					else if ((true))
					{
						alt17 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 17, 3, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((EvaluatePredicate(synpred1_Truss_fragment)))
				{
					alt17 = 1;
				}
				else if ((true))
				{
					alt17 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:2522:13: ( '.' DIGIT )=> ( '.' ( DIGIT )+ )? ( EXPONENT )? ( FLOAT_SUFFIX )?
					{
					DebugLocation(2522, 30);
					// Truss.g:2522:30: ( '.' ( DIGIT )+ )?
					int alt14=2;
					try { DebugEnterSubRule(14);
					try { DebugEnterDecision(14, false);
					int LA14_1 = input.LA(1);

					if ((LA14_1=='.'))
					{
						alt14 = 1;
					}
					} finally { DebugExitDecision(14); }
					switch (alt14)
					{
					case 1:
						DebugEnterAlt(1);
						// Truss.g:2522:32: '.' ( DIGIT )+
						{
						DebugLocation(2522, 32);
						Match('.'); if (state.failed) return;
						DebugLocation(2522, 36);
						// Truss.g:2522:36: ( DIGIT )+
						int cnt13=0;
						try { DebugEnterSubRule(13);
						while (true)
						{
							int alt13=2;
							try { DebugEnterDecision(13, false);
							int LA13_1 = input.LA(1);

							if (((LA13_1>='0' && LA13_1<='9')))
							{
								alt13 = 1;
							}


							} finally { DebugExitDecision(13); }
							switch (alt13)
							{
							case 1:
								DebugEnterAlt(1);
								// Truss.g:
								{
								DebugLocation(2522, 36);
								input.Consume();
								state.failed=false;

								}
								break;

							default:
								if (cnt13 >= 1)
									goto loop13;

								if (state.backtracking>0) {state.failed=true; return;}
								EarlyExitException eee13 = new EarlyExitException( 13, input );
								DebugRecognitionException(eee13);
								throw eee13;
							}
							cnt13++;
						}
						loop13:
							;

						} finally { DebugExitSubRule(13); }


						}
						break;

					}
					} finally { DebugExitSubRule(14); }

					DebugLocation(2522, 46);
					// Truss.g:2522:46: ( EXPONENT )?
					int alt15=2;
					try { DebugEnterSubRule(15);
					try { DebugEnterDecision(15, false);
					int LA15_1 = input.LA(1);

					if ((LA15_1=='E'||LA15_1=='e'))
					{
						alt15 = 1;
					}
					} finally { DebugExitDecision(15); }
					switch (alt15)
					{
					case 1:
						DebugEnterAlt(1);
						// Truss.g:2522:46: EXPONENT
						{
						DebugLocation(2522, 46);
						mEXPONENT(); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(15); }

					DebugLocation(2522, 56);
					// Truss.g:2522:56: ( FLOAT_SUFFIX )?
					int alt16=2;
					try { DebugEnterSubRule(16);
					try { DebugEnterDecision(16, false);
					int LA16_1 = input.LA(1);

					if ((LA16_1=='D'||LA16_1=='F'||LA16_1=='M'||LA16_1=='d'||LA16_1=='f'||LA16_1=='m'))
					{
						alt16 = 1;
					}
					} finally { DebugExitDecision(16); }
					switch (alt16)
					{
					case 1:
						DebugEnterAlt(1);
						// Truss.g:
						{
						DebugLocation(2522, 56);
						input.Consume();
						state.failed=false;

						}
						break;

					}
					} finally { DebugExitSubRule(16); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Truss.g:2524:13: FLOAT_SUFFIX
					{
					DebugLocation(2524, 13);
					mFLOAT_SUFFIX(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Truss.g:2526:13: 
					{
					DebugLocation(2526, 13);
					if (state.backtracking == 0)
					{
						 _type = INTEGER; 
					}

					}
					break;

				}
				} finally { DebugExitSubRule(17); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Truss.g:2529:9: '.' ( DIGIT )+ ( EXPONENT )? ( FLOAT_SUFFIX )?
				{
				DebugLocation(2529, 9);
				Match('.'); if (state.failed) return;
				DebugLocation(2529, 13);
				// Truss.g:2529:13: ( DIGIT )+
				int cnt18=0;
				try { DebugEnterSubRule(18);
				while (true)
				{
					int alt18=2;
					try { DebugEnterDecision(18, false);
					int LA18_1 = input.LA(1);

					if (((LA18_1>='0' && LA18_1<='9')))
					{
						alt18 = 1;
					}


					} finally { DebugExitDecision(18); }
					switch (alt18)
					{
					case 1:
						DebugEnterAlt(1);
						// Truss.g:
						{
						DebugLocation(2529, 13);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt18 >= 1)
							goto loop18;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee18 = new EarlyExitException( 18, input );
						DebugRecognitionException(eee18);
						throw eee18;
					}
					cnt18++;
				}
				loop18:
					;

				} finally { DebugExitSubRule(18); }

				DebugLocation(2529, 20);
				// Truss.g:2529:20: ( EXPONENT )?
				int alt19=2;
				try { DebugEnterSubRule(19);
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1=='E'||LA19_1=='e'))
				{
					alt19 = 1;
				}
				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:2529:20: EXPONENT
					{
					DebugLocation(2529, 20);
					mEXPONENT(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(19); }

				DebugLocation(2529, 30);
				// Truss.g:2529:30: ( FLOAT_SUFFIX )?
				int alt20=2;
				try { DebugEnterSubRule(20);
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1=='D'||LA20_1=='F'||LA20_1=='M'||LA20_1=='d'||LA20_1=='f'||LA20_1=='m'))
				{
					alt20 = 1;
				}
				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:
					{
					DebugLocation(2529, 30);
					input.Consume();
					state.failed=false;

					}
					break;

				}
				} finally { DebugExitSubRule(20); }


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FLOAT", 146);
			LeaveRule("FLOAT", 146);
			LeaveRule_FLOAT();
		}
	}
	// $ANTLR end "FLOAT"

	partial void EnterRule_LITERAL_STRING();
	partial void LeaveRule_LITERAL_STRING();

	// $ANTLR start "LITERAL_STRING"
	[GrammarRule("LITERAL_STRING")]
	private void mLITERAL_STRING()
	{
		EnterRule_LITERAL_STRING();
		EnterRule("LITERAL_STRING", 147);
		TraceIn("LITERAL_STRING", 147);
		try
		{
			// Truss.g:2537:5: ( '\"' ( '\\\\' . |~ ( '\"' | '\\\\' | NEW_LINE_CHARACTER ) )* '\"' )
			DebugEnterAlt(1);
			// Truss.g:2537:7: '\"' ( '\\\\' . |~ ( '\"' | '\\\\' | NEW_LINE_CHARACTER ) )* '\"'
			{
			DebugLocation(2537, 7);
			Match('\"'); if (state.failed) return;
			DebugLocation(2537, 11);
			// Truss.g:2537:11: ( '\\\\' . |~ ( '\"' | '\\\\' | NEW_LINE_CHARACTER ) )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=3;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1=='\\'))
				{
					alt22 = 1;
				}
				else if (((LA22_1>='\u0000' && LA22_1<='\t')||(LA22_1>='\u000B' && LA22_1<='\f')||(LA22_1>='\u000E' && LA22_1<='!')||(LA22_1>='#' && LA22_1<='[')||(LA22_1>=']' && LA22_1<='\u0084')||(LA22_1>='\u0086' && LA22_1<='\u2027')||(LA22_1>='\u202A' && LA22_1<='\uFFFF')))
				{
					alt22 = 2;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:2537:13: '\\\\' .
					{
					DebugLocation(2537, 13);
					Match('\\'); if (state.failed) return;
					DebugLocation(2537, 18);
					MatchAny(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Truss.g:2537:22: ~ ( '\"' | '\\\\' | NEW_LINE_CHARACTER )
					{
					DebugLocation(2537, 22);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }

			DebugLocation(2537, 62);
			Match('\"'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("LITERAL_STRING", 147);
			LeaveRule("LITERAL_STRING", 147);
			LeaveRule_LITERAL_STRING();
		}
	}
	// $ANTLR end "LITERAL_STRING"

	partial void EnterRule_VERBATIM_STRING();
	partial void LeaveRule_VERBATIM_STRING();

	// $ANTLR start "VERBATIM_STRING"
	[GrammarRule("VERBATIM_STRING")]
	private void mVERBATIM_STRING()
	{
		EnterRule_VERBATIM_STRING();
		EnterRule("VERBATIM_STRING", 148);
		TraceIn("VERBATIM_STRING", 148);
		try
		{
			// Truss.g:2541:5: ( '@\"' ( '\"\"' |~ '\"' ) '\"' )
			DebugEnterAlt(1);
			// Truss.g:2541:7: '@\"' ( '\"\"' |~ '\"' ) '\"'
			{
			DebugLocation(2541, 7);
			Match("@\""); if (state.failed) return;

			DebugLocation(2541, 12);
			// Truss.g:2541:12: ( '\"\"' |~ '\"' )
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1=='\"'))
			{
				alt23 = 1;
			}
			else if (((LA23_1>='\u0000' && LA23_1<='!')||(LA23_1>='#' && LA23_1<='\uFFFF')))
			{
				alt23 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 23, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// Truss.g:2541:14: '\"\"'
				{
				DebugLocation(2541, 14);
				Match("\"\""); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Truss.g:2541:21: ~ '\"'
				{
				DebugLocation(2541, 21);
				input.Consume();
				state.failed=false;

				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(2541, 28);
			Match('\"'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("VERBATIM_STRING", 148);
			LeaveRule("VERBATIM_STRING", 148);
			LeaveRule_VERBATIM_STRING();
		}
	}
	// $ANTLR end "VERBATIM_STRING"

	partial void EnterRule_STRING();
	partial void LeaveRule_STRING();

	// $ANTLR start "STRING"
	[GrammarRule("STRING")]
	private void mSTRING()
	{
		EnterRule_STRING();
		EnterRule("STRING", 149);
		TraceIn("STRING", 149);
		try
		{
			int _type = STRING;
			int _channel = DefaultTokenChannel;
			// Truss.g:2544:8: ( LITERAL_STRING | VERBATIM_STRING )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1=='\"'))
			{
				alt24 = 1;
			}
			else if ((LA24_1=='@'))
			{
				alt24 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 24, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// Truss.g:2544:10: LITERAL_STRING
				{
				DebugLocation(2544, 10);
				mLITERAL_STRING(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Truss.g:2544:27: VERBATIM_STRING
				{
				DebugLocation(2544, 27);
				mVERBATIM_STRING(); if (state.failed) return;

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING", 149);
			LeaveRule("STRING", 149);
			LeaveRule_STRING();
		}
	}
	// $ANTLR end "STRING"

	partial void EnterRule_CHAR();
	partial void LeaveRule_CHAR();

	// $ANTLR start "CHAR"
	[GrammarRule("CHAR")]
	private void mCHAR()
	{
		EnterRule_CHAR();
		EnterRule("CHAR", 150);
		TraceIn("CHAR", 150);
		try
		{
			int _type = CHAR;
			int _channel = DefaultTokenChannel;
			// Truss.g:2547:5: ( '\\'' ( '\\\\' . |~ ( '\\'' | '\\\\' ) )* '\\'' )
			DebugEnterAlt(1);
			// Truss.g:2547:7: '\\'' ( '\\\\' . |~ ( '\\'' | '\\\\' ) )* '\\''
			{
			DebugLocation(2547, 7);
			Match('\''); if (state.failed) return;
			DebugLocation(2547, 12);
			// Truss.g:2547:12: ( '\\\\' . |~ ( '\\'' | '\\\\' ) )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=3;
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1=='\\'))
				{
					alt25 = 1;
				}
				else if (((LA25_1>='\u0000' && LA25_1<='&')||(LA25_1>='(' && LA25_1<='[')||(LA25_1>=']' && LA25_1<='\uFFFF')))
				{
					alt25 = 2;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// Truss.g:2547:14: '\\\\' .
					{
					DebugLocation(2547, 14);
					Match('\\'); if (state.failed) return;
					DebugLocation(2547, 19);
					MatchAny(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Truss.g:2547:23: ~ ( '\\'' | '\\\\' )
					{
					DebugLocation(2547, 23);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }

			DebugLocation(2547, 43);
			Match('\''); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CHAR", 150);
			LeaveRule("CHAR", 150);
			LeaveRule_CHAR();
		}
	}
	// $ANTLR end "CHAR"

	public override void mTokens()
	{
		// Truss.g:1:8: ( KW_ABSTRACT | KW_AS | KW_ASSERT | KW_ASYNC | KW_AWAIT | KW_BASE | KW_BOOL | KW_BREAK | KW_BYTE | KW_CASE | KW_CATCH | KW_CHAR | KW_CLASS | KW_CONSUMES | KW_CONTINUE | KW_DECIMAL | KW_DEFAULT | KW_DELEGATE | KW_DELETE | KW_DO | KW_DOUBLE | KW_ELIF | KW_ELSE | KW_ENUM | KW_EVENT | KW_EXPLICIT | KW_EXTERN | KW_FALSE | KW_FINALLY | KW_FLOAT | KW_FOR | KW_FOREACH | KW_IF | KW_IMPLICIT | KW_IMPORT | KW_IN | KW_INT | KW_INTERFACE | KW_INTERNAL | KW_IS | KW_LONG | KW_LOOP | KW_NAMESPACE | KW_NEW | KW_NIL | KW_OBJECT | KW_OPERATOR | KW_OUT | KW_OVERRIDE | KW_PARAMS | KW_PARTIAL | KW_PRIVATE | KW_PROTECTED | KW_PUBLIC | KW_READONLY | KW_REF | KW_RETURN | KW_SBYTE | KW_SEALED | KW_SHORT | KW_SIZEOF | KW_STATIC | KW_STRING | KW_STRUCT | KW_SWITCH | KW_THIS | KW_THROW | KW_TRUE | KW_TRY | KW_TYPEOF | KW_UINT | KW_ULONG | KW_USHORT | KW_USING | KW_VAR | KW_VIRTUAL | KW_VOID | KW_VOLATILE | KW_WHERE | KW_WHILE | OP_AMPERSAND | OP_AMPERSAND_AMPERSAND | OP_AMPERSAND_EQUALS | OP_ASTERISK | OP_ASTERISK_EQUALS | OP_BAR | OP_BAR_BAR | OP_BAR_EQUALS | OP_BRACE_CLOSE | OP_BRACE_OPEN | OP_BRACKET_CLOSE | OP_BRACKET_OPEN | OP_CARET | OP_CARET_EQUALS | OP_COLON | OP_COLON_COLON | OP_COMMA | OP_DOT | OP_EQUALS | OP_EQUALS_EQUALS | OP_EQUALS_GREATER_THAN | OP_EXCLAMATION | OP_EXCLAMATION_EQUALS | OP_GREATER_THAN | OP_GREATER_THAN_EQUALS | OP_GREATER_THAN_GREATER_THAN | OP_GREATER_THAN_GREATER_THAN_EQUALS | OP_LESS_THAN | OP_LESS_THAN_EQUALS | OP_LESS_THAN_LESS_THAN | OP_LESS_THAN_LESS_THAN_EQUALS | OP_MINUS | OP_MINUS_EQUALS | OP_MINUS_MINUS | OP_PAREN_CLOSE | OP_PAREN_OPEN | OP_PERCENT | OP_PERCENT_EQUALS | OP_PLUS | OP_PLUS_EQUALS | OP_PLUS_PLUS | OP_QUESTION | OP_QUESTION_QUESTION | OP_SEMICOLON | OP_SLASH | OP_SLASH_EQUALS | OP_TILDE | NEW_LINE | LINE_COMMENT | BLOCK_COMMENT | WHITESPACE | IDENTIFIER | HEX_INTEGER | FLOAT | STRING | CHAR )
		int alt26=136;
		try { DebugEnterDecision(26, false);
		try
		{
			alt26 = dfa26.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(26); }
		switch (alt26)
		{
		case 1:
			DebugEnterAlt(1);
			// Truss.g:1:10: KW_ABSTRACT
			{
			DebugLocation(1, 10);
			mKW_ABSTRACT(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Truss.g:1:22: KW_AS
			{
			DebugLocation(1, 22);
			mKW_AS(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Truss.g:1:28: KW_ASSERT
			{
			DebugLocation(1, 28);
			mKW_ASSERT(); if (state.failed) return;

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Truss.g:1:38: KW_ASYNC
			{
			DebugLocation(1, 38);
			mKW_ASYNC(); if (state.failed) return;

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Truss.g:1:47: KW_AWAIT
			{
			DebugLocation(1, 47);
			mKW_AWAIT(); if (state.failed) return;

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Truss.g:1:56: KW_BASE
			{
			DebugLocation(1, 56);
			mKW_BASE(); if (state.failed) return;

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Truss.g:1:64: KW_BOOL
			{
			DebugLocation(1, 64);
			mKW_BOOL(); if (state.failed) return;

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Truss.g:1:72: KW_BREAK
			{
			DebugLocation(1, 72);
			mKW_BREAK(); if (state.failed) return;

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Truss.g:1:81: KW_BYTE
			{
			DebugLocation(1, 81);
			mKW_BYTE(); if (state.failed) return;

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Truss.g:1:89: KW_CASE
			{
			DebugLocation(1, 89);
			mKW_CASE(); if (state.failed) return;

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Truss.g:1:97: KW_CATCH
			{
			DebugLocation(1, 97);
			mKW_CATCH(); if (state.failed) return;

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Truss.g:1:106: KW_CHAR
			{
			DebugLocation(1, 106);
			mKW_CHAR(); if (state.failed) return;

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Truss.g:1:114: KW_CLASS
			{
			DebugLocation(1, 114);
			mKW_CLASS(); if (state.failed) return;

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Truss.g:1:123: KW_CONSUMES
			{
			DebugLocation(1, 123);
			mKW_CONSUMES(); if (state.failed) return;

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Truss.g:1:135: KW_CONTINUE
			{
			DebugLocation(1, 135);
			mKW_CONTINUE(); if (state.failed) return;

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Truss.g:1:147: KW_DECIMAL
			{
			DebugLocation(1, 147);
			mKW_DECIMAL(); if (state.failed) return;

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Truss.g:1:158: KW_DEFAULT
			{
			DebugLocation(1, 158);
			mKW_DEFAULT(); if (state.failed) return;

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// Truss.g:1:169: KW_DELEGATE
			{
			DebugLocation(1, 169);
			mKW_DELEGATE(); if (state.failed) return;

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// Truss.g:1:181: KW_DELETE
			{
			DebugLocation(1, 181);
			mKW_DELETE(); if (state.failed) return;

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// Truss.g:1:191: KW_DO
			{
			DebugLocation(1, 191);
			mKW_DO(); if (state.failed) return;

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// Truss.g:1:197: KW_DOUBLE
			{
			DebugLocation(1, 197);
			mKW_DOUBLE(); if (state.failed) return;

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// Truss.g:1:207: KW_ELIF
			{
			DebugLocation(1, 207);
			mKW_ELIF(); if (state.failed) return;

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// Truss.g:1:215: KW_ELSE
			{
			DebugLocation(1, 215);
			mKW_ELSE(); if (state.failed) return;

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// Truss.g:1:223: KW_ENUM
			{
			DebugLocation(1, 223);
			mKW_ENUM(); if (state.failed) return;

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// Truss.g:1:231: KW_EVENT
			{
			DebugLocation(1, 231);
			mKW_EVENT(); if (state.failed) return;

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// Truss.g:1:240: KW_EXPLICIT
			{
			DebugLocation(1, 240);
			mKW_EXPLICIT(); if (state.failed) return;

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// Truss.g:1:252: KW_EXTERN
			{
			DebugLocation(1, 252);
			mKW_EXTERN(); if (state.failed) return;

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// Truss.g:1:262: KW_FALSE
			{
			DebugLocation(1, 262);
			mKW_FALSE(); if (state.failed) return;

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// Truss.g:1:271: KW_FINALLY
			{
			DebugLocation(1, 271);
			mKW_FINALLY(); if (state.failed) return;

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// Truss.g:1:282: KW_FLOAT
			{
			DebugLocation(1, 282);
			mKW_FLOAT(); if (state.failed) return;

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// Truss.g:1:291: KW_FOR
			{
			DebugLocation(1, 291);
			mKW_FOR(); if (state.failed) return;

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// Truss.g:1:298: KW_FOREACH
			{
			DebugLocation(1, 298);
			mKW_FOREACH(); if (state.failed) return;

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// Truss.g:1:309: KW_IF
			{
			DebugLocation(1, 309);
			mKW_IF(); if (state.failed) return;

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// Truss.g:1:315: KW_IMPLICIT
			{
			DebugLocation(1, 315);
			mKW_IMPLICIT(); if (state.failed) return;

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// Truss.g:1:327: KW_IMPORT
			{
			DebugLocation(1, 327);
			mKW_IMPORT(); if (state.failed) return;

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// Truss.g:1:337: KW_IN
			{
			DebugLocation(1, 337);
			mKW_IN(); if (state.failed) return;

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// Truss.g:1:343: KW_INT
			{
			DebugLocation(1, 343);
			mKW_INT(); if (state.failed) return;

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// Truss.g:1:350: KW_INTERFACE
			{
			DebugLocation(1, 350);
			mKW_INTERFACE(); if (state.failed) return;

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// Truss.g:1:363: KW_INTERNAL
			{
			DebugLocation(1, 363);
			mKW_INTERNAL(); if (state.failed) return;

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// Truss.g:1:375: KW_IS
			{
			DebugLocation(1, 375);
			mKW_IS(); if (state.failed) return;

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// Truss.g:1:381: KW_LONG
			{
			DebugLocation(1, 381);
			mKW_LONG(); if (state.failed) return;

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// Truss.g:1:389: KW_LOOP
			{
			DebugLocation(1, 389);
			mKW_LOOP(); if (state.failed) return;

			}
			break;
		case 43:
			DebugEnterAlt(43);
			// Truss.g:1:397: KW_NAMESPACE
			{
			DebugLocation(1, 397);
			mKW_NAMESPACE(); if (state.failed) return;

			}
			break;
		case 44:
			DebugEnterAlt(44);
			// Truss.g:1:410: KW_NEW
			{
			DebugLocation(1, 410);
			mKW_NEW(); if (state.failed) return;

			}
			break;
		case 45:
			DebugEnterAlt(45);
			// Truss.g:1:417: KW_NIL
			{
			DebugLocation(1, 417);
			mKW_NIL(); if (state.failed) return;

			}
			break;
		case 46:
			DebugEnterAlt(46);
			// Truss.g:1:424: KW_OBJECT
			{
			DebugLocation(1, 424);
			mKW_OBJECT(); if (state.failed) return;

			}
			break;
		case 47:
			DebugEnterAlt(47);
			// Truss.g:1:434: KW_OPERATOR
			{
			DebugLocation(1, 434);
			mKW_OPERATOR(); if (state.failed) return;

			}
			break;
		case 48:
			DebugEnterAlt(48);
			// Truss.g:1:446: KW_OUT
			{
			DebugLocation(1, 446);
			mKW_OUT(); if (state.failed) return;

			}
			break;
		case 49:
			DebugEnterAlt(49);
			// Truss.g:1:453: KW_OVERRIDE
			{
			DebugLocation(1, 453);
			mKW_OVERRIDE(); if (state.failed) return;

			}
			break;
		case 50:
			DebugEnterAlt(50);
			// Truss.g:1:465: KW_PARAMS
			{
			DebugLocation(1, 465);
			mKW_PARAMS(); if (state.failed) return;

			}
			break;
		case 51:
			DebugEnterAlt(51);
			// Truss.g:1:475: KW_PARTIAL
			{
			DebugLocation(1, 475);
			mKW_PARTIAL(); if (state.failed) return;

			}
			break;
		case 52:
			DebugEnterAlt(52);
			// Truss.g:1:486: KW_PRIVATE
			{
			DebugLocation(1, 486);
			mKW_PRIVATE(); if (state.failed) return;

			}
			break;
		case 53:
			DebugEnterAlt(53);
			// Truss.g:1:497: KW_PROTECTED
			{
			DebugLocation(1, 497);
			mKW_PROTECTED(); if (state.failed) return;

			}
			break;
		case 54:
			DebugEnterAlt(54);
			// Truss.g:1:510: KW_PUBLIC
			{
			DebugLocation(1, 510);
			mKW_PUBLIC(); if (state.failed) return;

			}
			break;
		case 55:
			DebugEnterAlt(55);
			// Truss.g:1:520: KW_READONLY
			{
			DebugLocation(1, 520);
			mKW_READONLY(); if (state.failed) return;

			}
			break;
		case 56:
			DebugEnterAlt(56);
			// Truss.g:1:532: KW_REF
			{
			DebugLocation(1, 532);
			mKW_REF(); if (state.failed) return;

			}
			break;
		case 57:
			DebugEnterAlt(57);
			// Truss.g:1:539: KW_RETURN
			{
			DebugLocation(1, 539);
			mKW_RETURN(); if (state.failed) return;

			}
			break;
		case 58:
			DebugEnterAlt(58);
			// Truss.g:1:549: KW_SBYTE
			{
			DebugLocation(1, 549);
			mKW_SBYTE(); if (state.failed) return;

			}
			break;
		case 59:
			DebugEnterAlt(59);
			// Truss.g:1:558: KW_SEALED
			{
			DebugLocation(1, 558);
			mKW_SEALED(); if (state.failed) return;

			}
			break;
		case 60:
			DebugEnterAlt(60);
			// Truss.g:1:568: KW_SHORT
			{
			DebugLocation(1, 568);
			mKW_SHORT(); if (state.failed) return;

			}
			break;
		case 61:
			DebugEnterAlt(61);
			// Truss.g:1:577: KW_SIZEOF
			{
			DebugLocation(1, 577);
			mKW_SIZEOF(); if (state.failed) return;

			}
			break;
		case 62:
			DebugEnterAlt(62);
			// Truss.g:1:587: KW_STATIC
			{
			DebugLocation(1, 587);
			mKW_STATIC(); if (state.failed) return;

			}
			break;
		case 63:
			DebugEnterAlt(63);
			// Truss.g:1:597: KW_STRING
			{
			DebugLocation(1, 597);
			mKW_STRING(); if (state.failed) return;

			}
			break;
		case 64:
			DebugEnterAlt(64);
			// Truss.g:1:607: KW_STRUCT
			{
			DebugLocation(1, 607);
			mKW_STRUCT(); if (state.failed) return;

			}
			break;
		case 65:
			DebugEnterAlt(65);
			// Truss.g:1:617: KW_SWITCH
			{
			DebugLocation(1, 617);
			mKW_SWITCH(); if (state.failed) return;

			}
			break;
		case 66:
			DebugEnterAlt(66);
			// Truss.g:1:627: KW_THIS
			{
			DebugLocation(1, 627);
			mKW_THIS(); if (state.failed) return;

			}
			break;
		case 67:
			DebugEnterAlt(67);
			// Truss.g:1:635: KW_THROW
			{
			DebugLocation(1, 635);
			mKW_THROW(); if (state.failed) return;

			}
			break;
		case 68:
			DebugEnterAlt(68);
			// Truss.g:1:644: KW_TRUE
			{
			DebugLocation(1, 644);
			mKW_TRUE(); if (state.failed) return;

			}
			break;
		case 69:
			DebugEnterAlt(69);
			// Truss.g:1:652: KW_TRY
			{
			DebugLocation(1, 652);
			mKW_TRY(); if (state.failed) return;

			}
			break;
		case 70:
			DebugEnterAlt(70);
			// Truss.g:1:659: KW_TYPEOF
			{
			DebugLocation(1, 659);
			mKW_TYPEOF(); if (state.failed) return;

			}
			break;
		case 71:
			DebugEnterAlt(71);
			// Truss.g:1:669: KW_UINT
			{
			DebugLocation(1, 669);
			mKW_UINT(); if (state.failed) return;

			}
			break;
		case 72:
			DebugEnterAlt(72);
			// Truss.g:1:677: KW_ULONG
			{
			DebugLocation(1, 677);
			mKW_ULONG(); if (state.failed) return;

			}
			break;
		case 73:
			DebugEnterAlt(73);
			// Truss.g:1:686: KW_USHORT
			{
			DebugLocation(1, 686);
			mKW_USHORT(); if (state.failed) return;

			}
			break;
		case 74:
			DebugEnterAlt(74);
			// Truss.g:1:696: KW_USING
			{
			DebugLocation(1, 696);
			mKW_USING(); if (state.failed) return;

			}
			break;
		case 75:
			DebugEnterAlt(75);
			// Truss.g:1:705: KW_VAR
			{
			DebugLocation(1, 705);
			mKW_VAR(); if (state.failed) return;

			}
			break;
		case 76:
			DebugEnterAlt(76);
			// Truss.g:1:712: KW_VIRTUAL
			{
			DebugLocation(1, 712);
			mKW_VIRTUAL(); if (state.failed) return;

			}
			break;
		case 77:
			DebugEnterAlt(77);
			// Truss.g:1:723: KW_VOID
			{
			DebugLocation(1, 723);
			mKW_VOID(); if (state.failed) return;

			}
			break;
		case 78:
			DebugEnterAlt(78);
			// Truss.g:1:731: KW_VOLATILE
			{
			DebugLocation(1, 731);
			mKW_VOLATILE(); if (state.failed) return;

			}
			break;
		case 79:
			DebugEnterAlt(79);
			// Truss.g:1:743: KW_WHERE
			{
			DebugLocation(1, 743);
			mKW_WHERE(); if (state.failed) return;

			}
			break;
		case 80:
			DebugEnterAlt(80);
			// Truss.g:1:752: KW_WHILE
			{
			DebugLocation(1, 752);
			mKW_WHILE(); if (state.failed) return;

			}
			break;
		case 81:
			DebugEnterAlt(81);
			// Truss.g:1:761: OP_AMPERSAND
			{
			DebugLocation(1, 761);
			mOP_AMPERSAND(); if (state.failed) return;

			}
			break;
		case 82:
			DebugEnterAlt(82);
			// Truss.g:1:774: OP_AMPERSAND_AMPERSAND
			{
			DebugLocation(1, 774);
			mOP_AMPERSAND_AMPERSAND(); if (state.failed) return;

			}
			break;
		case 83:
			DebugEnterAlt(83);
			// Truss.g:1:797: OP_AMPERSAND_EQUALS
			{
			DebugLocation(1, 797);
			mOP_AMPERSAND_EQUALS(); if (state.failed) return;

			}
			break;
		case 84:
			DebugEnterAlt(84);
			// Truss.g:1:817: OP_ASTERISK
			{
			DebugLocation(1, 817);
			mOP_ASTERISK(); if (state.failed) return;

			}
			break;
		case 85:
			DebugEnterAlt(85);
			// Truss.g:1:829: OP_ASTERISK_EQUALS
			{
			DebugLocation(1, 829);
			mOP_ASTERISK_EQUALS(); if (state.failed) return;

			}
			break;
		case 86:
			DebugEnterAlt(86);
			// Truss.g:1:848: OP_BAR
			{
			DebugLocation(1, 848);
			mOP_BAR(); if (state.failed) return;

			}
			break;
		case 87:
			DebugEnterAlt(87);
			// Truss.g:1:855: OP_BAR_BAR
			{
			DebugLocation(1, 855);
			mOP_BAR_BAR(); if (state.failed) return;

			}
			break;
		case 88:
			DebugEnterAlt(88);
			// Truss.g:1:866: OP_BAR_EQUALS
			{
			DebugLocation(1, 866);
			mOP_BAR_EQUALS(); if (state.failed) return;

			}
			break;
		case 89:
			DebugEnterAlt(89);
			// Truss.g:1:880: OP_BRACE_CLOSE
			{
			DebugLocation(1, 880);
			mOP_BRACE_CLOSE(); if (state.failed) return;

			}
			break;
		case 90:
			DebugEnterAlt(90);
			// Truss.g:1:895: OP_BRACE_OPEN
			{
			DebugLocation(1, 895);
			mOP_BRACE_OPEN(); if (state.failed) return;

			}
			break;
		case 91:
			DebugEnterAlt(91);
			// Truss.g:1:909: OP_BRACKET_CLOSE
			{
			DebugLocation(1, 909);
			mOP_BRACKET_CLOSE(); if (state.failed) return;

			}
			break;
		case 92:
			DebugEnterAlt(92);
			// Truss.g:1:926: OP_BRACKET_OPEN
			{
			DebugLocation(1, 926);
			mOP_BRACKET_OPEN(); if (state.failed) return;

			}
			break;
		case 93:
			DebugEnterAlt(93);
			// Truss.g:1:942: OP_CARET
			{
			DebugLocation(1, 942);
			mOP_CARET(); if (state.failed) return;

			}
			break;
		case 94:
			DebugEnterAlt(94);
			// Truss.g:1:951: OP_CARET_EQUALS
			{
			DebugLocation(1, 951);
			mOP_CARET_EQUALS(); if (state.failed) return;

			}
			break;
		case 95:
			DebugEnterAlt(95);
			// Truss.g:1:967: OP_COLON
			{
			DebugLocation(1, 967);
			mOP_COLON(); if (state.failed) return;

			}
			break;
		case 96:
			DebugEnterAlt(96);
			// Truss.g:1:976: OP_COLON_COLON
			{
			DebugLocation(1, 976);
			mOP_COLON_COLON(); if (state.failed) return;

			}
			break;
		case 97:
			DebugEnterAlt(97);
			// Truss.g:1:991: OP_COMMA
			{
			DebugLocation(1, 991);
			mOP_COMMA(); if (state.failed) return;

			}
			break;
		case 98:
			DebugEnterAlt(98);
			// Truss.g:1:1000: OP_DOT
			{
			DebugLocation(1, 1000);
			mOP_DOT(); if (state.failed) return;

			}
			break;
		case 99:
			DebugEnterAlt(99);
			// Truss.g:1:1007: OP_EQUALS
			{
			DebugLocation(1, 1007);
			mOP_EQUALS(); if (state.failed) return;

			}
			break;
		case 100:
			DebugEnterAlt(100);
			// Truss.g:1:1017: OP_EQUALS_EQUALS
			{
			DebugLocation(1, 1017);
			mOP_EQUALS_EQUALS(); if (state.failed) return;

			}
			break;
		case 101:
			DebugEnterAlt(101);
			// Truss.g:1:1034: OP_EQUALS_GREATER_THAN
			{
			DebugLocation(1, 1034);
			mOP_EQUALS_GREATER_THAN(); if (state.failed) return;

			}
			break;
		case 102:
			DebugEnterAlt(102);
			// Truss.g:1:1057: OP_EXCLAMATION
			{
			DebugLocation(1, 1057);
			mOP_EXCLAMATION(); if (state.failed) return;

			}
			break;
		case 103:
			DebugEnterAlt(103);
			// Truss.g:1:1072: OP_EXCLAMATION_EQUALS
			{
			DebugLocation(1, 1072);
			mOP_EXCLAMATION_EQUALS(); if (state.failed) return;

			}
			break;
		case 104:
			DebugEnterAlt(104);
			// Truss.g:1:1094: OP_GREATER_THAN
			{
			DebugLocation(1, 1094);
			mOP_GREATER_THAN(); if (state.failed) return;

			}
			break;
		case 105:
			DebugEnterAlt(105);
			// Truss.g:1:1110: OP_GREATER_THAN_EQUALS
			{
			DebugLocation(1, 1110);
			mOP_GREATER_THAN_EQUALS(); if (state.failed) return;

			}
			break;
		case 106:
			DebugEnterAlt(106);
			// Truss.g:1:1133: OP_GREATER_THAN_GREATER_THAN
			{
			DebugLocation(1, 1133);
			mOP_GREATER_THAN_GREATER_THAN(); if (state.failed) return;

			}
			break;
		case 107:
			DebugEnterAlt(107);
			// Truss.g:1:1162: OP_GREATER_THAN_GREATER_THAN_EQUALS
			{
			DebugLocation(1, 1162);
			mOP_GREATER_THAN_GREATER_THAN_EQUALS(); if (state.failed) return;

			}
			break;
		case 108:
			DebugEnterAlt(108);
			// Truss.g:1:1198: OP_LESS_THAN
			{
			DebugLocation(1, 1198);
			mOP_LESS_THAN(); if (state.failed) return;

			}
			break;
		case 109:
			DebugEnterAlt(109);
			// Truss.g:1:1211: OP_LESS_THAN_EQUALS
			{
			DebugLocation(1, 1211);
			mOP_LESS_THAN_EQUALS(); if (state.failed) return;

			}
			break;
		case 110:
			DebugEnterAlt(110);
			// Truss.g:1:1231: OP_LESS_THAN_LESS_THAN
			{
			DebugLocation(1, 1231);
			mOP_LESS_THAN_LESS_THAN(); if (state.failed) return;

			}
			break;
		case 111:
			DebugEnterAlt(111);
			// Truss.g:1:1254: OP_LESS_THAN_LESS_THAN_EQUALS
			{
			DebugLocation(1, 1254);
			mOP_LESS_THAN_LESS_THAN_EQUALS(); if (state.failed) return;

			}
			break;
		case 112:
			DebugEnterAlt(112);
			// Truss.g:1:1284: OP_MINUS
			{
			DebugLocation(1, 1284);
			mOP_MINUS(); if (state.failed) return;

			}
			break;
		case 113:
			DebugEnterAlt(113);
			// Truss.g:1:1293: OP_MINUS_EQUALS
			{
			DebugLocation(1, 1293);
			mOP_MINUS_EQUALS(); if (state.failed) return;

			}
			break;
		case 114:
			DebugEnterAlt(114);
			// Truss.g:1:1309: OP_MINUS_MINUS
			{
			DebugLocation(1, 1309);
			mOP_MINUS_MINUS(); if (state.failed) return;

			}
			break;
		case 115:
			DebugEnterAlt(115);
			// Truss.g:1:1324: OP_PAREN_CLOSE
			{
			DebugLocation(1, 1324);
			mOP_PAREN_CLOSE(); if (state.failed) return;

			}
			break;
		case 116:
			DebugEnterAlt(116);
			// Truss.g:1:1339: OP_PAREN_OPEN
			{
			DebugLocation(1, 1339);
			mOP_PAREN_OPEN(); if (state.failed) return;

			}
			break;
		case 117:
			DebugEnterAlt(117);
			// Truss.g:1:1353: OP_PERCENT
			{
			DebugLocation(1, 1353);
			mOP_PERCENT(); if (state.failed) return;

			}
			break;
		case 118:
			DebugEnterAlt(118);
			// Truss.g:1:1364: OP_PERCENT_EQUALS
			{
			DebugLocation(1, 1364);
			mOP_PERCENT_EQUALS(); if (state.failed) return;

			}
			break;
		case 119:
			DebugEnterAlt(119);
			// Truss.g:1:1382: OP_PLUS
			{
			DebugLocation(1, 1382);
			mOP_PLUS(); if (state.failed) return;

			}
			break;
		case 120:
			DebugEnterAlt(120);
			// Truss.g:1:1390: OP_PLUS_EQUALS
			{
			DebugLocation(1, 1390);
			mOP_PLUS_EQUALS(); if (state.failed) return;

			}
			break;
		case 121:
			DebugEnterAlt(121);
			// Truss.g:1:1405: OP_PLUS_PLUS
			{
			DebugLocation(1, 1405);
			mOP_PLUS_PLUS(); if (state.failed) return;

			}
			break;
		case 122:
			DebugEnterAlt(122);
			// Truss.g:1:1418: OP_QUESTION
			{
			DebugLocation(1, 1418);
			mOP_QUESTION(); if (state.failed) return;

			}
			break;
		case 123:
			DebugEnterAlt(123);
			// Truss.g:1:1430: OP_QUESTION_QUESTION
			{
			DebugLocation(1, 1430);
			mOP_QUESTION_QUESTION(); if (state.failed) return;

			}
			break;
		case 124:
			DebugEnterAlt(124);
			// Truss.g:1:1451: OP_SEMICOLON
			{
			DebugLocation(1, 1451);
			mOP_SEMICOLON(); if (state.failed) return;

			}
			break;
		case 125:
			DebugEnterAlt(125);
			// Truss.g:1:1464: OP_SLASH
			{
			DebugLocation(1, 1464);
			mOP_SLASH(); if (state.failed) return;

			}
			break;
		case 126:
			DebugEnterAlt(126);
			// Truss.g:1:1473: OP_SLASH_EQUALS
			{
			DebugLocation(1, 1473);
			mOP_SLASH_EQUALS(); if (state.failed) return;

			}
			break;
		case 127:
			DebugEnterAlt(127);
			// Truss.g:1:1489: OP_TILDE
			{
			DebugLocation(1, 1489);
			mOP_TILDE(); if (state.failed) return;

			}
			break;
		case 128:
			DebugEnterAlt(128);
			// Truss.g:1:1498: NEW_LINE
			{
			DebugLocation(1, 1498);
			mNEW_LINE(); if (state.failed) return;

			}
			break;
		case 129:
			DebugEnterAlt(129);
			// Truss.g:1:1507: LINE_COMMENT
			{
			DebugLocation(1, 1507);
			mLINE_COMMENT(); if (state.failed) return;

			}
			break;
		case 130:
			DebugEnterAlt(130);
			// Truss.g:1:1520: BLOCK_COMMENT
			{
			DebugLocation(1, 1520);
			mBLOCK_COMMENT(); if (state.failed) return;

			}
			break;
		case 131:
			DebugEnterAlt(131);
			// Truss.g:1:1534: WHITESPACE
			{
			DebugLocation(1, 1534);
			mWHITESPACE(); if (state.failed) return;

			}
			break;
		case 132:
			DebugEnterAlt(132);
			// Truss.g:1:1545: IDENTIFIER
			{
			DebugLocation(1, 1545);
			mIDENTIFIER(); if (state.failed) return;

			}
			break;
		case 133:
			DebugEnterAlt(133);
			// Truss.g:1:1556: HEX_INTEGER
			{
			DebugLocation(1, 1556);
			mHEX_INTEGER(); if (state.failed) return;

			}
			break;
		case 134:
			DebugEnterAlt(134);
			// Truss.g:1:1568: FLOAT
			{
			DebugLocation(1, 1568);
			mFLOAT(); if (state.failed) return;

			}
			break;
		case 135:
			DebugEnterAlt(135);
			// Truss.g:1:1574: STRING
			{
			DebugLocation(1, 1574);
			mSTRING(); if (state.failed) return;

			}
			break;
		case 136:
			DebugEnterAlt(136);
			// Truss.g:1:1581: CHAR
			{
			DebugLocation(1, 1581);
			mCHAR(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_Truss_fragment();
	partial void LeaveRule_synpred1_Truss_fragment();

	// $ANTLR start synpred1_Truss
	public void synpred1_Truss_fragment()
	{
		EnterRule_synpred1_Truss_fragment();
		EnterRule("synpred1_Truss_fragment", 152);
		TraceIn("synpred1_Truss_fragment", 152);
		try
		{
			// Truss.g:2522:13: ( '.' DIGIT )
			DebugEnterAlt(1);
			// Truss.g:2522:15: '.' DIGIT
			{
			DebugLocation(2522, 15);
			Match('.'); if (state.failed) return;
			DebugLocation(2522, 19);
			mDIGIT(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_Truss_fragment", 152);
			LeaveRule("synpred1_Truss_fragment", 152);
			LeaveRule_synpred1_Truss_fragment();
		}
	}
	// $ANTLR end synpred1_Truss

	#region Synpreds
	private bool EvaluatePredicate(Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	DFA26 dfa26;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa26 = new DFA26(this);
	}

	private class DFA26 : DFA
	{
		private const string DFA26_eotS =
			"\x1\xFFFF\xF\x2D\x1\x2B\x1\x2D\x1\x69\x1\x6B\x1\x6E\x4\xFFFF\x1\x70\x1"+
			"\x72\x1\xFFFF\x1\x73\x1\x76\x1\x78\x1\x7B\x1\x7E\x1\x81\x2\xFFFF\x1\x83"+
			"\x1\x86\x1\x88\x1\xFFFF\x1\x8C\x5\xFFFF\x1\x2F\x3\xFFFF\x1\x2D\x1\x91"+
			"\xA\x2D\x1\xA0\x8\x2D\x1\xAB\x1\x2D\x1\xAE\x1\xAF\x1C\x2D\x13\xFFFF\x1"+
			"\xD7\x2\xFFFF\x1\xD9\x10\xFFFF\x3\x2D\x1\xFFFF\xE\x2D\x1\xFFFF\x9\x2D"+
			"\x1\xF6\x1\xFFFF\x1\x2D\x1\xFA\x2\xFFFF\x3\x2D\x1\xFE\x1\xFF\x2\x2D\x1"+
			"\x102\x6\x2D\x1\x10A\xB\x2D\x1\x117\x5\x2D\x1\x11D\x5\x2D\x4\xFFFF\x4"+
			"\x2D\x1\x127\x1\x128\x1\x2D\x1\x12A\x1\x12B\x1\x2D\x1\x12D\x7\x2D\x1"+
			"\x136\x1\x137\x1\x138\x7\x2D\x1\xFFFF\x3\x2D\x1\xFFFF\x1\x143\x1\x144"+
			"\x1\x2D\x2\xFFFF\x2\x2D\x1\xFFFF\x7\x2D\x1\xFFFF\x9\x2D\x1\x158\x1\x2D"+
			"\x1\x15A\x1\xFFFF\x1\x2D\x1\x15C\x3\x2D\x1\xFFFF\x1\x2D\x1\x161\x5\x2D"+
			"\x1\x167\x1\x168\x2\xFFFF\x1\x169\x2\xFFFF\x1\x16A\x1\xFFFF\x1\x16B\x7"+
			"\x2D\x3\xFFFF\x1\x173\x2\x2D\x1\x176\x1\x2D\x1\x178\x4\x2D\x2\xFFFF\xB"+
			"\x2D\x1\x189\x1\x2D\x1\x18B\x5\x2D\x1\xFFFF\x1\x191\x1\xFFFF\x1\x2D\x1"+
			"\xFFFF\x1\x193\x1\x2D\x1\x195\x1\x2D\x1\xFFFF\x1\x2D\x1\x198\x1\x199"+
			"\x1\x2D\x1\x19B\x5\xFFFF\x5\x2D\x1\x1A1\x1\x1A2\x1\xFFFF\x1\x2D\x1\x1A4"+
			"\x1\xFFFF\x1\x2D\x1\xFFFF\x2\x2D\x1\x1A8\x3\x2D\x1\x1AC\x2\x2D\x1\x1AF"+
			"\x3\x2D\x1\x1B3\x1\x2D\x1\x1B5\x1\xFFFF\x1\x1B6\x1\xFFFF\x1\x1B7\x1\x1B8"+
			"\x1\x1B9\x1\x1BA\x1\x1BB\x1\xFFFF\x1\x1BC\x1\xFFFF\x1\x1BD\x1\xFFFF\x2"+
			"\x2D\x2\xFFFF\x1\x2D\x1\xFFFF\x2\x2D\x1\x1C3\x1\x1C4\x1\x2D\x2\xFFFF"+
			"\x1\x2D\x1\xFFFF\x1\x1C7\x1\x1C8\x1\x2D\x1\xFFFF\x3\x2D\x1\xFFFF\x2\x2D"+
			"\x1\xFFFF\x1\x1CF\x1\x1D0\x1\x2D\x1\xFFFF\x1\x2D\x9\xFFFF\x1\x1D3\x1"+
			"\x2D\x1\x1D5\x1\x1D6\x1\x1D7\x2\xFFFF\x1\x1D8\x1\x1D9\x2\xFFFF\x1\x1DA"+
			"\x1\x2D\x1\x1DC\x1\x2D\x1\x1DE\x1\x1DF\x2\xFFFF\x1\x2D\x1\x1E1\x1\xFFFF"+
			"\x1\x1E2\x6\xFFFF\x1\x1E3\x1\xFFFF\x1\x1E4\x2\xFFFF\x1\x1E5\x5\xFFFF";
		private const string DFA26_eofS =
			"\x1E6\xFFFF";
		private const string DFA26_minS =
			"\x1\x9\x1\x62\x2\x61\x1\x65\x1\x6C\x1\x61\x1\x66\x1\x6F\x1\x61\x1\x62"+
			"\x1\x61\x1\x65\x1\x62\x1\x68\x1\x69\x1\x30\x1\x68\x1\x26\x2\x3D\x4\xFFFF"+
			"\x1\x3D\x1\x3A\x1\xFFFF\x1\x30\x3\x3D\x1\x3C\x1\x2D\x2\xFFFF\x1\x3D\x1"+
			"\x2B\x1\x3F\x1\xFFFF\x1\x2A\x3\xFFFF\x1\x22\x1\xFFFF\x1\x58\x3\xFFFF"+
			"\x1\x73\x1\x30\x1\x61\x1\x73\x1\x6F\x1\x65\x1\x74\x1\x73\x2\x61\x1\x6E"+
			"\x1\x63\x1\x30\x1\x69\x1\x75\x1\x65\x1\x70\x1\x6C\x1\x6E\x1\x6F\x1\x72"+
			"\x1\x30\x1\x70\x2\x30\x1\x6E\x1\x6D\x1\x77\x1\x6C\x1\x6A\x1\x65\x1\x74"+
			"\x1\x65\x1\x72\x1\x69\x1\x62\x1\x61\x1\x79\x1\x61\x1\x6F\x1\x7A\x1\x61"+
			"\x2\x69\x1\x75\x1\x70\x1\x6E\x1\x6F\x1\x68\x2\x72\x1\x69\x1\x65\x13\xFFFF"+
			"\x1\x3D\x2\xFFFF\x1\x3D\x10\xFFFF\x1\x74\x1\x65\x1\x6E\x1\xFFFF\x1\x69"+
			"\x1\x65\x1\x6C\x1\x61\x2\x65\x1\x63\x1\x72\x2\x73\x1\x69\x1\x61\x1\x65"+
			"\x1\x62\x1\xFFFF\x1\x66\x1\x65\x1\x6D\x1\x6E\x1\x6C\x1\x65\x1\x73\x2"+
			"\x61\x1\x30\x1\xFFFF\x1\x6C\x1\x30\x2\xFFFF\x1\x67\x1\x70\x1\x65\x2\x30"+
			"\x1\x65\x1\x72\x1\x30\x1\x72\x1\x61\x1\x76\x1\x74\x1\x6C\x1\x64\x1\x30"+
			"\x1\x75\x1\x74\x1\x6C\x1\x72\x1\x65\x1\x74\x1\x69\x1\x74\x1\x73\x1\x6F"+
			"\x1\x65\x1\x30\x1\x65\x1\x74\x1\x6E\x1\x6F\x1\x6E\x1\x30\x1\x74\x1\x64"+
			"\x1\x61\x1\x72\x1\x6C\x4\xFFFF\x2\x72\x1\x63\x1\x74\x2\x30\x1\x6B\x2"+
			"\x30\x1\x68\x1\x30\x1\x73\x1\x75\x1\x69\x1\x6D\x1\x75\x1\x67\x1\x6C\x3"+
			"\x30\x1\x74\x1\x69\x1\x72\x1\x65\x1\x6C\x1\x74\x1\x61\x1\xFFFF\x1\x69"+
			"\x2\x72\x1\xFFFF\x2\x30\x1\x73\x2\xFFFF\x1\x63\x1\x61\x1\xFFFF\x1\x72"+
			"\x1\x6D\x1\x69\x1\x61\x1\x65\x1\x69\x1\x6F\x1\xFFFF\x1\x72\x2\x65\x1"+
			"\x74\x1\x6F\x1\x69\x1\x6E\x2\x63\x1\x30\x1\x77\x1\x30\x1\xFFFF\x1\x6F"+
			"\x1\x30\x1\x67\x1\x72\x1\x67\x1\xFFFF\x1\x75\x1\x30\x1\x74\x2\x65\x1"+
			"\x61\x1\x74\x2\x30\x2\xFFFF\x1\x30\x2\xFFFF\x1\x30\x1\xFFFF\x1\x30\x1"+
			"\x6D\x1\x6E\x1\x61\x1\x6C\x1\x61\x2\x65\x3\xFFFF\x1\x30\x1\x63\x1\x6E"+
			"\x1\x30\x1\x6C\x1\x30\x2\x63\x1\x74\x1\x66\x2\xFFFF\x1\x70\x2\x74\x1"+
			"\x69\x1\x73\x1\x61\x1\x74\x2\x63\x2\x6E\x1\x30\x1\x64\x1\x30\x1\x66\x1"+
			"\x63\x1\x67\x1\x74\x1\x68\x1\xFFFF\x1\x30\x1\xFFFF\x1\x66\x1\xFFFF\x1"+
			"\x30\x1\x74\x1\x30\x1\x61\x1\xFFFF\x1\x69\x2\x30\x1\x63\x1\x30\x5\xFFFF"+
			"\x1\x65\x1\x75\x1\x6C\x2\x74\x2\x30\x1\xFFFF\x1\x69\x1\x30\x1\xFFFF\x1"+
			"\x79\x1\xFFFF\x1\x68\x1\x69\x1\x30\x3\x61\x1\x30\x1\x6F\x1\x64\x1\x30"+
			"\x1\x6C\x1\x65\x1\x74\x1\x30\x1\x6C\x1\x30\x1\xFFFF\x1\x30\x1\xFFFF\x5"+
			"\x30\x1\xFFFF\x1\x30\x1\xFFFF\x1\x30\x1\xFFFF\x2\x6C\x2\xFFFF\x1\x74"+
			"\x1\xFFFF\x1\x73\x1\x65\x2\x30\x1\x65\x2\xFFFF\x1\x74\x1\xFFFF\x2\x30"+
			"\x1\x74\x1\xFFFF\x1\x63\x1\x6C\x1\x63\x1\xFFFF\x1\x72\x1\x65\x1\xFFFF"+
			"\x2\x30\x1\x65\x1\xFFFF\x1\x79\x9\xFFFF\x1\x30\x1\x65\x3\x30\x2\xFFFF"+
			"\x2\x30\x2\xFFFF\x1\x30\x1\x65\x1\x30\x1\x65\x2\x30\x2\xFFFF\x1\x64\x1"+
			"\x30\x1\xFFFF\x1\x30\x6\xFFFF\x1\x30\x1\xFFFF\x1\x30\x2\xFFFF\x1\x30"+
			"\x5\xFFFF";
		private const string DFA26_maxS =
			"\x1\x2029\x1\x77\x1\x79\x2\x6F\x1\x78\x1\x6F\x1\x73\x1\x6F\x1\x69\x1"+
			"\x76\x1\x75\x1\x65\x1\x77\x1\x79\x1\x73\x1\x7A\x1\x68\x2\x3D\x1\x7C\x4"+
			"\xFFFF\x1\x3D\x1\x3A\x1\xFFFF\x1\x39\x1\x3E\x1\x3D\x1\x3E\x2\x3D\x2\xFFFF"+
			"\x2\x3D\x1\x3F\x1\xFFFF\x1\x3D\x3\xFFFF\x1\x7A\x1\xFFFF\x1\x78\x3\xFFFF"+
			"\x1\x73\x1\x7A\x1\x61\x1\x73\x1\x6F\x1\x65\x2\x74\x2\x61\x1\x6E\x1\x6C"+
			"\x1\x7A\x1\x73\x1\x75\x1\x65\x1\x74\x1\x6C\x1\x6E\x1\x6F\x1\x72\x1\x7A"+
			"\x1\x70\x2\x7A\x1\x6F\x1\x6D\x1\x77\x1\x6C\x1\x6A\x1\x65\x1\x74\x1\x65"+
			"\x1\x72\x1\x6F\x1\x62\x1\x74\x1\x79\x1\x61\x1\x6F\x1\x7A\x1\x72\x1\x69"+
			"\x1\x72\x1\x79\x1\x70\x1\x6E\x1\x6F\x1\x69\x2\x72\x1\x6C\x1\x69\x13\xFFFF"+
			"\x1\x3D\x2\xFFFF\x1\x3D\x10\xFFFF\x1\x74\x1\x65\x1\x6E\x1\xFFFF\x1\x69"+
			"\x1\x65\x1\x6C\x1\x61\x2\x65\x1\x63\x1\x72\x1\x73\x1\x74\x1\x69\x1\x61"+
			"\x1\x65\x1\x62\x1\xFFFF\x1\x66\x1\x65\x1\x6D\x1\x6E\x1\x6C\x1\x65\x1"+
			"\x73\x2\x61\x1\x7A\x1\xFFFF\x1\x6F\x1\x7A\x2\xFFFF\x1\x67\x1\x70\x1\x65"+
			"\x2\x7A\x1\x65\x1\x72\x1\x7A\x1\x72\x1\x74\x1\x76\x1\x74\x1\x6C\x1\x64"+
			"\x1\x7A\x1\x75\x1\x74\x1\x6C\x1\x72\x1\x65\x1\x74\x1\x75\x1\x74\x1\x73"+
			"\x1\x6F\x1\x65\x1\x7A\x1\x65\x1\x74\x1\x6E\x1\x6F\x1\x6E\x1\x7A\x1\x74"+
			"\x1\x64\x1\x61\x1\x72\x1\x6C\x4\xFFFF\x2\x72\x1\x63\x1\x74\x2\x7A\x1"+
			"\x6B\x2\x7A\x1\x68\x1\x7A\x1\x73\x1\x75\x1\x69\x1\x6D\x1\x75\x1\x74\x1"+
			"\x6C\x3\x7A\x1\x74\x1\x69\x1\x72\x1\x65\x1\x6C\x1\x74\x1\x61\x1\xFFFF"+
			"\x1\x69\x2\x72\x1\xFFFF\x2\x7A\x1\x73\x2\xFFFF\x1\x63\x1\x61\x1\xFFFF"+
			"\x1\x72\x1\x6D\x1\x69\x1\x61\x1\x65\x1\x69\x1\x6F\x1\xFFFF\x1\x72\x2"+
			"\x65\x1\x74\x1\x6F\x1\x69\x1\x6E\x2\x63\x1\x7A\x1\x77\x1\x7A\x1\xFFFF"+
			"\x1\x6F\x1\x7A\x1\x67\x1\x72\x1\x67\x1\xFFFF\x1\x75\x1\x7A\x1\x74\x2"+
			"\x65\x1\x61\x1\x74\x2\x7A\x2\xFFFF\x1\x7A\x2\xFFFF\x1\x7A\x1\xFFFF\x1"+
			"\x7A\x1\x6D\x1\x6E\x1\x61\x1\x6C\x1\x61\x2\x65\x3\xFFFF\x1\x7A\x1\x63"+
			"\x1\x6E\x1\x7A\x1\x6C\x1\x7A\x2\x63\x1\x74\x1\x6E\x2\xFFFF\x1\x70\x2"+
			"\x74\x1\x69\x1\x73\x1\x61\x1\x74\x2\x63\x2\x6E\x1\x7A\x1\x64\x1\x7A\x1"+
			"\x66\x1\x63\x1\x67\x1\x74\x1\x68\x1\xFFFF\x1\x7A\x1\xFFFF\x1\x66\x1\xFFFF"+
			"\x1\x7A\x1\x74\x1\x7A\x1\x61\x1\xFFFF\x1\x69\x2\x7A\x1\x63\x1\x7A\x5"+
			"\xFFFF\x1\x65\x1\x75\x1\x6C\x2\x74\x2\x7A\x1\xFFFF\x1\x69\x1\x7A\x1\xFFFF"+
			"\x1\x79\x1\xFFFF\x1\x68\x1\x69\x1\x7A\x3\x61\x1\x7A\x1\x6F\x1\x64\x1"+
			"\x7A\x1\x6C\x1\x65\x1\x74\x1\x7A\x1\x6C\x1\x7A\x1\xFFFF\x1\x7A\x1\xFFFF"+
			"\x5\x7A\x1\xFFFF\x1\x7A\x1\xFFFF\x1\x7A\x1\xFFFF\x2\x6C\x2\xFFFF\x1\x74"+
			"\x1\xFFFF\x1\x73\x1\x65\x2\x7A\x1\x65\x2\xFFFF\x1\x74\x1\xFFFF\x2\x7A"+
			"\x1\x74\x1\xFFFF\x1\x63\x1\x6C\x1\x63\x1\xFFFF\x1\x72\x1\x65\x1\xFFFF"+
			"\x2\x7A\x1\x65\x1\xFFFF\x1\x79\x9\xFFFF\x1\x7A\x1\x65\x3\x7A\x2\xFFFF"+
			"\x2\x7A\x2\xFFFF\x1\x7A\x1\x65\x1\x7A\x1\x65\x2\x7A\x2\xFFFF\x1\x64\x1"+
			"\x7A\x1\xFFFF\x1\x7A\x6\xFFFF\x1\x7A\x1\xFFFF\x1\x7A\x2\xFFFF\x1\x7A"+
			"\x5\xFFFF";
		private const string DFA26_acceptS =
			"\x15\xFFFF\x1\x59\x1\x5A\x1\x5B\x1\x5C\x2\xFFFF\x1\x61\x6\xFFFF\x1\x73"+
			"\x1\x74\x3\xFFFF\x1\x7C\x1\xFFFF\x1\x7F\x1\x80\x1\x83\x1\xFFFF\x1\x84"+
			"\x1\xFFFF\x1\x86\x1\x87\x1\x88\x35\xFFFF\x1\x52\x1\x53\x1\x51\x1\x55"+
			"\x1\x54\x1\x57\x1\x58\x1\x56\x1\x5E\x1\x5D\x1\x60\x1\x5F\x1\x62\x1\x64"+
			"\x1\x65\x1\x63\x1\x67\x1\x66\x1\x69\x1\xFFFF\x1\x68\x1\x6D\x1\xFFFF\x1"+
			"\x6C\x1\x71\x1\x72\x1\x70\x1\x76\x1\x75\x1\x78\x1\x79\x1\x77\x1\x7B\x1"+
			"\x7A\x1\x7E\x1\x81\x1\x82\x1\x7D\x1\x85\x3\xFFFF\x1\x2\xE\xFFFF\x1\x14"+
			"\xA\xFFFF\x1\x21\x2\xFFFF\x1\x24\x1\x28\x26\xFFFF\x1\x6B\x1\x6A\x1\x6F"+
			"\x1\x6E\x1C\xFFFF\x1\x1F\x3\xFFFF\x1\x25\x3\xFFFF\x1\x2C\x1\x2D\x2\xFFFF"+
			"\x1\x30\x7\xFFFF\x1\x38\xC\xFFFF\x1\x45\x5\xFFFF\x1\x4B\x9\xFFFF\x1\x6"+
			"\x1\x7\x1\xFFFF\x1\x9\x1\xA\x1\xFFFF\x1\xC\x8\xFFFF\x1\x16\x1\x17\x1"+
			"\x18\xA\xFFFF\x1\x29\x1\x2A\x13\xFFFF\x1\x42\x1\xFFFF\x1\x44\x1\xFFFF"+
			"\x1\x47\x4\xFFFF\x1\x4D\x5\xFFFF\x1\x4\x1\x5\x1\x8\x1\xB\x1\xD\x7\xFFFF"+
			"\x1\x19\x2\xFFFF\x1\x1C\x1\xFFFF\x1\x1E\x10\xFFFF\x1\x3A\x1\xFFFF\x1"+
			"\x3C\x5\xFFFF\x1\x43\x1\xFFFF\x1\x48\x1\xFFFF\x1\x4A\x2\xFFFF\x1\x4F"+
			"\x1\x50\x1\xFFFF\x1\x3\x5\xFFFF\x1\x13\x1\x15\x1\xFFFF\x1\x1B\x3\xFFFF"+
			"\x1\x23\x3\xFFFF\x1\x2E\x2\xFFFF\x1\x32\x3\xFFFF\x1\x36\x1\xFFFF\x1\x39"+
			"\x1\x3B\x1\x3D\x1\x3E\x1\x3F\x1\x40\x1\x41\x1\x46\x1\x49\x5\xFFFF\x1"+
			"\x10\x1\x11\x2\xFFFF\x1\x1D\x1\x20\x6\xFFFF\x1\x33\x1\x34\x2\xFFFF\x1"+
			"\x4C\x1\xFFFF\x1\x1\x1\xE\x1\xF\x1\x12\x1\x1A\x1\x22\x1\xFFFF\x1\x27"+
			"\x1\xFFFF\x1\x2F\x1\x31\x1\xFFFF\x1\x37\x1\x4E\x1\x26\x1\x2B\x1\x35";
		private const string DFA26_specialS =
			"\x1E6\xFFFF}>";
		private static readonly string[] DFA26_transitionS =
			{
				"\x1\x2B\x1\x2A\x1\xFFFF\x1\x2B\x1\x2A\x12\xFFFF\x1\x2B\x1\x1E\x1\x30"+
				"\x2\xFFFF\x1\x24\x1\x12\x1\x31\x1\x23\x1\x22\x1\x13\x1\x25\x1\x1B\x1"+
				"\x21\x1\x1C\x1\x28\x1\x2E\x9\x2F\x1\x1A\x1\x27\x1\x20\x1\x1D\x1\x1F"+
				"\x1\x26\x1\x2C\x1A\x2D\x1\x18\x1\xFFFF\x1\x17\x1\x19\x1\x2D\x1\xFFFF"+
				"\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x2\x2D\x1\x7\x2\x2D\x1\x8\x1\x2D"+
				"\x1\x9\x1\xA\x1\xB\x1\x2D\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x3\x2D"+
				"\x1\x16\x1\x14\x1\x15\x1\x29\x6\xFFFF\x1\x2A\x1FA2\xFFFF\x2\x2A",
				"\x1\x32\x10\xFFFF\x1\x33\x3\xFFFF\x1\x34",
				"\x1\x35\xD\xFFFF\x1\x36\x2\xFFFF\x1\x37\x6\xFFFF\x1\x38",
				"\x1\x39\x6\xFFFF\x1\x3A\x3\xFFFF\x1\x3B\x2\xFFFF\x1\x3C",
				"\x1\x3D\x9\xFFFF\x1\x3E",
				"\x1\x3F\x1\xFFFF\x1\x40\x7\xFFFF\x1\x41\x1\xFFFF\x1\x42",
				"\x1\x43\x7\xFFFF\x1\x44\x2\xFFFF\x1\x45\x2\xFFFF\x1\x46",
				"\x1\x47\x6\xFFFF\x1\x48\x1\x49\x4\xFFFF\x1\x4A",
				"\x1\x4B",
				"\x1\x4C\x3\xFFFF\x1\x4D\x3\xFFFF\x1\x4E",
				"\x1\x4F\xD\xFFFF\x1\x50\x4\xFFFF\x1\x51\x1\x52",
				"\x1\x53\x10\xFFFF\x1\x54\x2\xFFFF\x1\x55",
				"\x1\x56",
				"\x1\x57\x2\xFFFF\x1\x58\x2\xFFFF\x1\x59\x1\x5A\xA\xFFFF\x1\x5B\x2\xFFFF"+
				"\x1\x5C",
				"\x1\x5D\x9\xFFFF\x1\x5E\x6\xFFFF\x1\x5F",
				"\x1\x60\x2\xFFFF\x1\x61\x6\xFFFF\x1\x62",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1\x63\x7\x2D\x1\x64"+
				"\x5\x2D\x1\x65\xB\x2D",
				"\x1\x66",
				"\x1\x67\x16\xFFFF\x1\x68",
				"\x1\x6A",
				"\x1\x6D\x3E\xFFFF\x1\x6C",
				"",
				"",
				"",
				"",
				"\x1\x6F",
				"\x1\x71",
				"",
				"\xA\x2F",
				"\x1\x74\x1\x75",
				"\x1\x77",
				"\x1\x79\x1\x7A",
				"\x1\x7D\x1\x7C",
				"\x1\x80\xF\xFFFF\x1\x7F",
				"",
				"",
				"\x1\x82",
				"\x1\x85\x11\xFFFF\x1\x84",
				"\x1\x87",
				"",
				"\x1\x8B\x4\xFFFF\x1\x8A\xD\xFFFF\x1\x89",
				"",
				"",
				"",
				"\x1\x30\x1E\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\x1\x8D\x1F\xFFFF\x1\x8D",
				"",
				"",
				"",
				"\x1\x8E",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x12\x2D\x1\x8F\x5"+
				"\x2D\x1\x90\x1\x2D",
				"\x1\x92",
				"\x1\x93",
				"\x1\x94",
				"\x1\x95",
				"\x1\x96",
				"\x1\x97\x1\x98",
				"\x1\x99",
				"\x1\x9A",
				"\x1\x9B",
				"\x1\x9C\x2\xFFFF\x1\x9D\x5\xFFFF\x1\x9E",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x14\x2D\x1\x9F\x5"+
				"\x2D",
				"\x1\xA1\x9\xFFFF\x1\xA2",
				"\x1\xA3",
				"\x1\xA4",
				"\x1\xA5\x3\xFFFF\x1\xA6",
				"\x1\xA7",
				"\x1\xA8",
				"\x1\xA9",
				"\x1\xAA",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\xAC",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x13\x2D\x1\xAD\x6"+
				"\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\xB0\x1\xB1",
				"\x1\xB2",
				"\x1\xB3",
				"\x1\xB4",
				"\x1\xB5",
				"\x1\xB6",
				"\x1\xB7",
				"\x1\xB8",
				"\x1\xB9",
				"\x1\xBA\x5\xFFFF\x1\xBB",
				"\x1\xBC",
				"\x1\xBD\x4\xFFFF\x1\xBE\xD\xFFFF\x1\xBF",
				"\x1\xC0",
				"\x1\xC1",
				"\x1\xC2",
				"\x1\xC3",
				"\x1\xC4\x10\xFFFF\x1\xC5",
				"\x1\xC6",
				"\x1\xC7\x8\xFFFF\x1\xC8",
				"\x1\xC9\x3\xFFFF\x1\xCA",
				"\x1\xCB",
				"\x1\xCC",
				"\x1\xCD",
				"\x1\xCE\x1\xCF",
				"\x1\xD0",
				"\x1\xD1",
				"\x1\xD2\x2\xFFFF\x1\xD3",
				"\x1\xD4\x3\xFFFF\x1\xD5",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xD6",
				"",
				"",
				"\x1\xD8",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xDA",
				"\x1\xDB",
				"\x1\xDC",
				"",
				"\x1\xDD",
				"\x1\xDE",
				"\x1\xDF",
				"\x1\xE0",
				"\x1\xE1",
				"\x1\xE2",
				"\x1\xE3",
				"\x1\xE4",
				"\x1\xE5",
				"\x1\xE6\x1\xE7",
				"\x1\xE8",
				"\x1\xE9",
				"\x1\xEA",
				"\x1\xEB",
				"",
				"\x1\xEC",
				"\x1\xED",
				"\x1\xEE",
				"\x1\xEF",
				"\x1\xF0",
				"\x1\xF1",
				"\x1\xF2",
				"\x1\xF3",
				"\x1\xF4",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x4\x2D\x1\xF5\x15"+
				"\x2D",
				"",
				"\x1\xF7\x2\xFFFF\x1\xF8",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x4\x2D\x1\xF9\x15"+
				"\x2D",
				"",
				"",
				"\x1\xFB",
				"\x1\xFC",
				"\x1\xFD",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x100",
				"\x1\x101",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x103",
				"\x1\x104\x12\xFFFF\x1\x105",
				"\x1\x106",
				"\x1\x107",
				"\x1\x108",
				"\x1\x109",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x10B",
				"\x1\x10C",
				"\x1\x10D",
				"\x1\x10E",
				"\x1\x10F",
				"\x1\x110",
				"\x1\x111\xB\xFFFF\x1\x112",
				"\x1\x113",
				"\x1\x114",
				"\x1\x115",
				"\x1\x116",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x118",
				"\x1\x119",
				"\x1\x11A",
				"\x1\x11B",
				"\x1\x11C",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x11E",
				"\x1\x11F",
				"\x1\x120",
				"\x1\x121",
				"\x1\x122",
				"",
				"",
				"",
				"",
				"\x1\x123",
				"\x1\x124",
				"\x1\x125",
				"\x1\x126",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x129",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x12C",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x12E",
				"\x1\x12F",
				"\x1\x130",
				"\x1\x131",
				"\x1\x132",
				"\x1\x133\xC\xFFFF\x1\x134",
				"\x1\x135",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x139",
				"\x1\x13A",
				"\x1\x13B",
				"\x1\x13C",
				"\x1\x13D",
				"\x1\x13E",
				"\x1\x13F",
				"",
				"\x1\x140",
				"\x1\x141",
				"\x1\x142",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x145",
				"",
				"",
				"\x1\x146",
				"\x1\x147",
				"",
				"\x1\x148",
				"\x1\x149",
				"\x1\x14A",
				"\x1\x14B",
				"\x1\x14C",
				"\x1\x14D",
				"\x1\x14E",
				"",
				"\x1\x14F",
				"\x1\x150",
				"\x1\x151",
				"\x1\x152",
				"\x1\x153",
				"\x1\x154",
				"\x1\x155",
				"\x1\x156",
				"\x1\x157",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x159",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\x1\x15B",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x15D",
				"\x1\x15E",
				"\x1\x15F",
				"",
				"\x1\x160",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x162",
				"\x1\x163",
				"\x1\x164",
				"\x1\x165",
				"\x1\x166",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x16C",
				"\x1\x16D",
				"\x1\x16E",
				"\x1\x16F",
				"\x1\x170",
				"\x1\x171",
				"\x1\x172",
				"",
				"",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x174",
				"\x1\x175",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x177",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x179",
				"\x1\x17A",
				"\x1\x17B",
				"\x1\x17C\x7\xFFFF\x1\x17D",
				"",
				"",
				"\x1\x17E",
				"\x1\x17F",
				"\x1\x180",
				"\x1\x181",
				"\x1\x182",
				"\x1\x183",
				"\x1\x184",
				"\x1\x185",
				"\x1\x186",
				"\x1\x187",
				"\x1\x188",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x18A",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x18C",
				"\x1\x18D",
				"\x1\x18E",
				"\x1\x18F",
				"\x1\x190",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\x1\x192",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x194",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x196",
				"",
				"\x1\x197",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x19A",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"",
				"",
				"",
				"",
				"\x1\x19C",
				"\x1\x19D",
				"\x1\x19E",
				"\x1\x19F",
				"\x1\x1A0",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\x1\x1A3",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\x1\x1A5",
				"",
				"\x1\x1A6",
				"\x1\x1A7",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1A9",
				"\x1\x1AA",
				"\x1\x1AB",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1AD",
				"\x1\x1AE",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1B0",
				"\x1\x1B1",
				"\x1\x1B2",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1B4",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\x1\x1BE",
				"\x1\x1BF",
				"",
				"",
				"\x1\x1C0",
				"",
				"\x1\x1C1",
				"\x1\x1C2",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1C5",
				"",
				"",
				"\x1\x1C6",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1C9",
				"",
				"\x1\x1CA",
				"\x1\x1CB",
				"\x1\x1CC",
				"",
				"\x1\x1CD",
				"\x1\x1CE",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1D1",
				"",
				"\x1\x1D2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1D4",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1DB",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\x1\x1DD",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"",
				"\x1\x1E0",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"",
				"",
				"",
				"",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"",
				"\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A\x2D",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA26_eot = DFA.UnpackEncodedString(DFA26_eotS);
		private static readonly short[] DFA26_eof = DFA.UnpackEncodedString(DFA26_eofS);
		private static readonly char[] DFA26_min = DFA.UnpackEncodedStringToUnsignedChars(DFA26_minS);
		private static readonly char[] DFA26_max = DFA.UnpackEncodedStringToUnsignedChars(DFA26_maxS);
		private static readonly short[] DFA26_accept = DFA.UnpackEncodedString(DFA26_acceptS);
		private static readonly short[] DFA26_special = DFA.UnpackEncodedString(DFA26_specialS);
		private static readonly short[][] DFA26_transition;

		static DFA26()
		{
			int numStates = DFA26_transitionS.Length;
			DFA26_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA26_transition[i] = DFA.UnpackEncodedString(DFA26_transitionS[i]);
			}
		}

		public DFA26( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 26;
			this.eot = DFA26_eot;
			this.eof = DFA26_eof;
			this.min = DFA26_min;
			this.max = DFA26_max;
			this.accept = DFA26_accept;
			this.special = DFA26_special;
			this.transition = DFA26_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( KW_ABSTRACT | KW_AS | KW_ASSERT | KW_ASYNC | KW_AWAIT | KW_BASE | KW_BOOL | KW_BREAK | KW_BYTE | KW_CASE | KW_CATCH | KW_CHAR | KW_CLASS | KW_CONSUMES | KW_CONTINUE | KW_DECIMAL | KW_DEFAULT | KW_DELEGATE | KW_DELETE | KW_DO | KW_DOUBLE | KW_ELIF | KW_ELSE | KW_ENUM | KW_EVENT | KW_EXPLICIT | KW_EXTERN | KW_FALSE | KW_FINALLY | KW_FLOAT | KW_FOR | KW_FOREACH | KW_IF | KW_IMPLICIT | KW_IMPORT | KW_IN | KW_INT | KW_INTERFACE | KW_INTERNAL | KW_IS | KW_LONG | KW_LOOP | KW_NAMESPACE | KW_NEW | KW_NIL | KW_OBJECT | KW_OPERATOR | KW_OUT | KW_OVERRIDE | KW_PARAMS | KW_PARTIAL | KW_PRIVATE | KW_PROTECTED | KW_PUBLIC | KW_READONLY | KW_REF | KW_RETURN | KW_SBYTE | KW_SEALED | KW_SHORT | KW_SIZEOF | KW_STATIC | KW_STRING | KW_STRUCT | KW_SWITCH | KW_THIS | KW_THROW | KW_TRUE | KW_TRY | KW_TYPEOF | KW_UINT | KW_ULONG | KW_USHORT | KW_USING | KW_VAR | KW_VIRTUAL | KW_VOID | KW_VOLATILE | KW_WHERE | KW_WHILE | OP_AMPERSAND | OP_AMPERSAND_AMPERSAND | OP_AMPERSAND_EQUALS | OP_ASTERISK | OP_ASTERISK_EQUALS | OP_BAR | OP_BAR_BAR | OP_BAR_EQUALS | OP_BRACE_CLOSE | OP_BRACE_OPEN | OP_BRACKET_CLOSE | OP_BRACKET_OPEN | OP_CARET | OP_CARET_EQUALS | OP_COLON | OP_COLON_COLON | OP_COMMA | OP_DOT | OP_EQUALS | OP_EQUALS_EQUALS | OP_EQUALS_GREATER_THAN | OP_EXCLAMATION | OP_EXCLAMATION_EQUALS | OP_GREATER_THAN | OP_GREATER_THAN_EQUALS | OP_GREATER_THAN_GREATER_THAN | OP_GREATER_THAN_GREATER_THAN_EQUALS | OP_LESS_THAN | OP_LESS_THAN_EQUALS | OP_LESS_THAN_LESS_THAN | OP_LESS_THAN_LESS_THAN_EQUALS | OP_MINUS | OP_MINUS_EQUALS | OP_MINUS_MINUS | OP_PAREN_CLOSE | OP_PAREN_OPEN | OP_PERCENT | OP_PERCENT_EQUALS | OP_PLUS | OP_PLUS_EQUALS | OP_PLUS_PLUS | OP_QUESTION | OP_QUESTION_QUESTION | OP_SEMICOLON | OP_SLASH | OP_SLASH_EQUALS | OP_TILDE | NEW_LINE | LINE_COMMENT | BLOCK_COMMENT | WHITESPACE | IDENTIFIER | HEX_INTEGER | FLOAT | STRING | CHAR );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

 
	#endregion

}

} // namespace  Truss.Compiler.Parser 
